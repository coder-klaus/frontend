Buffer是Node.js的全局类，无需导入，直接使用。它专门用来存储和处理二进制数据

Buffer本质上是一个字节数组，每一项是一个字节（8位二进制），Buffer里每个字节通常以二位的十六进制数显示

```js
// 创建一个 Buffer
let buffer1 = new Buffer('hello');
// 可以传入数值，创建一个指定大小的 Buffer
// 但分配的内存不会初始化，需要手动初始化
// 如果分配的内存原本存在敏感数据，会泄露
// 所以 new Buffer 不推荐使用
let buffer2 = new Buffer(5);

console.log(buffer1) // <Buffer 68 65 6c 6c 6f>
console.log(buffer2) // <Buffer 00 00 00 00 00>
```

```js
// new Buffer 被拆分为了 Buffer.from 和 Buffer.alloc

// 基于值创建 Buffer
let buffer = Buffer.from('hello');
console.log(buffer) // <Buffer 68 65 6c 6c 6f>

// 分配内存
let buffer2 = Buffer.alloc(5);
// 此时分配的内容会被自动初始化
console.log(buffer2) // <Buffer 00 00 00 00 00>

// 早期的 new Buffer方法行为 和 Buffer.allocUnsafe 一样，分配内存但不进行初始化
let buffer3 = Buffer.allocUnsafe(5);
console.log(buffer3) // <Buffer 00 00 00 00 00>
```

```js
// 中文字符串转 Buffer
// 底层使用 utf-8 编码 => 一个汉字占3个字节
let buffer3 = Buffer.from('你好');
console.log(buffer3); // 输出: <Buffer e4 bd a0 e5 a5 bd>
console.log(buffer3.toString()); // 输出: 你好
```

**编码的本质**确实是为了让计算机能够存储和处理各种类型的数据（如文字、图片、音频等），我们需要把这些数据转换成计算机可以理解和存储的二进制形式。

- **编码**：就是把数据（如字符串、图片等）按照某种规则转换为二进制数据（字节序列）。
- **解码**：则是把二进制数据（字节序列）还原为原始数据（如字符串等）。

不同的数据类型和应用场景，会采用不同的编码方式。例如，文本常用的编码有 UTF-8、GBK、ASCII 等，图片、音频等也有各自的编码标准。

```js
// 创建一个 8 字节的 Buffer
let buffer = Buffer.alloc(8); // <Buffer 00 00 00 00 00 00 00 00>

// Buffer 本质就是一个存放二进制数据的类数组 => 是 TypedArray 定义中的 Uint8Array
// 访问 Buffer 的第 0 个字节
console.log(buffer[0]); // 输出: 0

// 修改第 0 个字节
buffer[0] = 100; // 100 转为十六进制是 0x64
console.log(buffer); // 输出: <Buffer 64 00 00 00 00 00 00 00>
console.log(buffer.toString()); // 输出: d
```



如果每次创建 Buffer 都向操作系统申请内存，性能会很差

Node.js 的源码里有个优化：它不会每次都申请，而是先申请一块大的内存（默认 8KB，即 8×1024 字节），不管你实际要用多少字节。比如你只申请 8 字节，Node.js 还是会先申请 8KB 的内存池（Pool）。

每次使用Buffer的时候，Node.js 会检查内存池剩余空间是否够存字符串，如果内存池剩余空间够，就直接用；不够就再申请新的8kb的内存池。这种优化减少了向操作系统频繁申请内存的次数。

还有个特殊情况：如果字符串特别大，比如超过 4KB（源码里有个判断条件），Node.js 会直接为这个字符串申请单独的内存，而不是用 8KB 内存池。