## glboal

在 Node.js 中，全局对象不是 `window`，而是 `global`：

```js
console.log(global); // 输出 Node.js 的全局对象

// 在 Node.js 中，globalThis 指向的就是 global
console.log(globalThis === global); // true
console.log(global.global === global); // true
```



### 全局方法

许多在浏览器中属于 `window` 的全局方法和对象，在 Node.js 里同样被挂载到了 `global`（或 `globalThis`）上，例如 `console`、定时器函数（如 `setTimeout`）、`Number`、`Set`、`Map` 等。

但并不是所有浏览器全局对象都在 Node.js 存在。例如，Node.js（18 及以上）提供了 `fetch`，但没有 `XMLHttpRequest`、`document`、`window` 等与浏览器环境相关的对象。同时，Node.js 也有自己的全局对象，如 `process`、`Buffer` 等。



#### console对象

```js
// 输出信息到控制台
console.log('hello node');

// 其余打印方式 在node中 输出方式 和 node 完全一致，所以很少使用
console.error('error message')     // 输出错误信息
console.warn('警告信息');           // 输出警告信息
console.info('提示信息');           // 输出提示信息

// 输出当前的调用栈信息
console.trace();

// 清空控制台
console.clear();

// 计时：用于测试一段代码的执行时间
console.time('timer')
setTimeout(() => {
  // 定时器执行有延迟
  console.timeEnd('timer') // 打印 timer: 1.001ms
}, 1000)
```



##### console.dir

```js
// 默认情况下，一些内置对象可能存在自己默认的输出方式
// 通过 console.dir 可以让这些对象强制以对象结构输出，从而方便查看对象上的属性和方法

// 对于普通对象，console.log 和 console.dir 的输出基本相同，都是以对象结构展示。
console.log({ x: 1, y: 2 });
console.dir({ x: 1, y: 2 });

// 在浏览器环境下，对于 DOM 元素，console.log 会以 HTML 元素的形式展示
// 而 console.dir 则以对象的结构展开，便于查看其所有属性和方法，这对于调试 DOM 很有帮助。
// const div = document.createElement('div');
// console.log(div); // 显示为一个 HTML 元素
// console.dir(div); // 显示为一个对象，属性、方法全展开
```

```js
// 在 Node.js 环境中，由于没有 DOM 和 BOM 对象，console.dir 和 console.log 的表现几乎一致。
// 但 console.dir 可以设置 depth 参数，来控制输出对象的层级深度。

const user = {
  name: '张三',
  age: 18,
  friend: {
    name: '李四',
    age: 19,
    friend: {
      name: '王五',
      age: 20
    }
  }
};

console.log(user);
/*
  {
    name: '张三',
    age: 18,
    friend: { name: '李四', age: 19, friend: { name: '王五', age: 20 } }
  }
*/

// depth 为 1 表示只输出顶层属性对应的 key 和 value
console.dir(user, { depth: 1 });
/*
  {
    name: '张三',
    age: 18,
    friend: { name: '李四', age: 19, friend: [Object] }
  }
*/
```



##### 调用栈

调用栈（Call Stack）是 JavaScript 在执行函数时用来记录**函数调用顺序**的一个结构。

它能清楚地反映**谁调用了谁**，帮助我们定位代码执行到哪里、错误发生在什么位置。

假设有如下代码：

```js
function a() {
  b();
}
function b() {
  c();
}
function c() {
  console.trace('这里出错了');
}
a();
```

运行结果可能如下：

```shell
Trace: 这里出错了
    at c (.../test.js:7:11) # 触发console.trace的地方
    at b (.../test.js:4:3) # c方法被b调用
    at a (.../test.js:2:3) # b方法被a调用
    at Object.<anonymous> (.../test.js:9:1)
```

这份输出就展示了**函数的调用路径**，即 `a` 调用了 `b`，`b` 调用了 `c`，`c` 里发生了事件。



#### 定时器

```js
// setTimeout 用于延时执行
const timer = setTimeout(() => {
  console.log('timeout message');
  // 取消定时器
  clearTimeout(timer);
}, 1000);

// setInterval 用于周期性执行
const interval = setInterval(() => {
  console.log('interval message');
  // 取消定时器
  clearInterval(interval);
}, 1000);
```



## 注意事项

### 不存在隐式全局变量

在 Node.js 中，每个文件都是一个模块，拥有自己的模块作用域。

在编译时

+ 如果使用 ESM, 会自动开启严格模式
+ 如果使用CJS, 会采用类似于ESM的严格模式

因此 如果在node 中定义隐式全局变量，会直接报错

```js
b = 2 // ReferenceError: b is not defined
```



### 没有全局 `name` 属性

在 Node.js 中，`globalThis`（或 `global`）对象默认没有 `name` 属性，因此输出 `undefined`。

```js
console.log(globalThis.name) // undefined
```

而在浏览器环境下，`window.name` 默认是空字符串 `""`。



### `var` 声明的变量不会挂载到全局对象

在 Node.js 的模块中，使用 `var` 声明的变量只在当前文件模块内有效，不会挂载到 `globalThis`（或 `global`）对象上。

但使用 `var` 声明的变量 依旧可以被重新赋值，所以依旧不推荐使用

```js
var a = 1
var a = 2

console.log(globalThis.a) // undefined
console.log(a) // 2
```



### global 属性和方法的直接访问

即可以通过 `global`来访问全局属性，也可以直接访问对应全局属性 

```js
console.log(globalThis.process === process) // true
```



### global是所有模块共有的

`math.js`

```js
globalThis.add = (a, b) => a + b
globalThis.sub = (a, b) => a - b
globalThis.mul = (a, b) => a * b
```

`main.js`

```js
require('./utils/math.js')

console.log(globalThis.add(1, 2))
console.log(globalThis.sub(1, 2))
console.log(globalThis.mul(1, 2))
```

模块对象是`module`，而只要是同一个node进程，他们就可以共享一个全局对象`global`

但实际并不推荐手动像`global`上挂载内容，因为这破坏了模块化原则
