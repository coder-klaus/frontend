Koa 的 next方法返回 promise，我们可以通过await等待 下一个中间件执行完毕后，再执行后续代码

```js
import Koa from 'koa';

const app = new Koa();

// 模拟异步请求
const sleep = (ms = 1500) => new Promise(resolve => setTimeout(resolve, ms));

app.use(async (ctx, next) => {
  console.log(1)
  await next()
  console.log(2)
  ctx.body = 'Hello World'
});

app.use(async (ctx, next) => {
  console.log(3)
  await sleep()
  // Koa的next的返回值是Promise对象，所以可以await
  // 等待下一个中间件执行完后，再执行后续操作
  await next()
  console.log(4)
});

app.use(async (ctx, next) => {
  console.log(5)
  await sleep()
  // 因为没有下一个中间件了，所以这一句等于什么都没有做
  await next()
  console.log(6)
});

/*
  请求后，控制台输出的日志为
  1
  3
  5
  6
  4
  2
  然后再返回响应体
*/

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});
```

这样我们就可以在 `next`之前执行对于请求体的相关操作，而在 `next`后执行对于响应体的相关操作

简单来说就是 `请求从外到内，响应从内到外`, 这样的架构模型被诚之为 `洋葱模型`。其本质是一种递归的结构

![img](https://s2.loli.net/2025/06/23/3WRoPgExMadvbeA.png) 



而 `Express` 的 `next`方法返回值是 `void`，其中间件无法回溯，只能以直线的方式交给下一个中间件继续执行，这种执行方式被称之为`瀑布流`

```js
import express from 'express'

const app = express()

app.use((req, res, next) => {
  console.log(1)
  next()
})

app.use((req, res, next) => {
  console.log(2)
  next()
})

app.use((req, res, next) => {
  console.log(3)
  res.end('Hello World')
})

app.listen(3000, () => {
  console.log('Server is running on port 3000')
})
/* 
  请求后，控制台输出的日志为
  1
  2
  3
  并最终返回 Hello World
*/
```

