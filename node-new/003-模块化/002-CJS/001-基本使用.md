Node.js 默认采用 CommonJS 模块化规范：

- **导出**：通过 `exports` 或 `module.exports` 导出模块内容
- **导入**：通过 `require` 函数引入其他模块

```shell
文件 A
  └── module.exports → 导出功能
文件 B
  └── require → 导入功能
```



## 基本使用

### 导出

```js
// CJS 中每一个文件都是一个独立模块 => module 对象 表示的就是当前模块对象
// exports 用于导出模块中的内容，默认值是一个空对象
// exports 本质是 module.exports的引用，实际上真正导出的是 module.exports

console.log(module.exports === exports) // true

exports.add = (a, b) => a + b
exports.sub = (a, b) => a - b
```



### 导入

```js
// 导入模块
// require导入的是module.exports导出的内容，其本质就是一个对象，所以可以直接解构
const { add, sub } = require('./math')

// 使用模块
console.log(add(1, 2))
console.log(sub(1, 2))
```



## module.exports

```js
const add = (a, b) => a + b
const sub = (a, b) => a - b

module.exports = {
  add,
  sub
}
```



`module.exports` 和 `exports`默认指向同一个对象，`exports`是`module.exports`的语法糖写法

```js
const add = (a, b) => a + b
const sub = (a, b) => a - b

exports.add = add

// 此时因为 module.exports 被重新赋值，所以 exports 不再指向 module.exports
// 而实际导出的是 module.exports 的值，因此实际导出的内容只有 sub，没有 add
module.exports = {
  sub
}
```



## 总结

默认情况下，`exports` 和 `module.exports` 都指向同一个对象，修改哪个都可以。

但如果你通过 `module.exports = {}` 赋值导出一个新对象，`exports` 就和它脱离关系了，此时 `require` 只会拿到 `module.exports` 的内容。

之所以存在 `exports`，是因为 CommonJS 规范里只有 `exports` 这个导出对象，并没有 `module.exports` 的概念。

而在 Node.js 中，每个文件都是一个模块，都是 `Module` 的实例，`module.exports` 是它的一个属性。

为了兼容 CommonJS 规范，Node.js 默认让 `exports` 和 `module.exports` 指向同一个对象。
