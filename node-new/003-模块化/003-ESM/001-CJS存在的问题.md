## CommonJS 的同步加载机制及其适用性

**CommonJS** 模块规范采用同步加载模块的方式。也就是说，当主程序执行到 `require` 方法时，会立即去加载对应的模块文件，并在模块加载和执行完成之前，阻塞后续代码的执行流程。例如：

```md
主程序
   |
   v
加载 AA.js 
   |
   v
等待 AA.js 加载完成 
   |
   v
继续执行后续操作
```

在服务端（如 Node.js）环境下，所有模块文件都存储在本地磁盘，读取速度较快。即使存在同步阻塞，也不会对整体性能造成明显影响。此外，服务端中涉及到的耗时操作（如网络请求、数据库操作等）通常都采用异步事件驱动的方式进行，不会阻塞主线程。



## CommonJS 不适用于浏览器端的原因

然而，**CommonJS 并不适合直接在浏览器端使用**。在浏览器环境下，模块文件需要通过网络请求从服务器获取。如果采用同步加载模式，模块之间的依赖关系会导致**串行的网络请求**，极大增加页面的白屏时间。例如：

```md
浏览器
   |
   v
下载 AA.js (等待服务器响应)
   |
   v
解析 AA.js (发现引用 BB.js)
   |
   v
下载 BB.js (再次等待)
   |
   v
解析 BB.js (可能还有其他引用)
   |
   v
页面加载完成
```

在项目规模较大、模块依赖复杂时，这种同步加载会导致页面必须等所有模块下载和解析完成后才能展示内容，用户体验非常差。



## 浏览器中的模块化方案

### 1. 原生 ES Module

- 仅在较新的浏览器中被支持，老版本浏览器无法识别。
- 每个被导入的模块都需要通过网络请求单独加载，可能导致请求次数增多。
- 只支持以完整 URL 路径导入模块，**不支持裸模块名**（如 `import x from 'lodash'`）。
- **必须明确写出文件和文件后缀**（如 `.js`），不能省略后缀名或文件名「 如`index.js` 」，否则会导致加载失败。



### 2. 构建工具（如 Webpack、Rollup、Vite 等）

- 在开发阶段将多个模块打包成一个或多个 JavaScript 文件，最终通过 `<script>` 标签加载，减少浏览器请求次数。
- 打包后的文件对所有浏览器兼容性更好，无需担心原生模块化支持问题。
- 支持使用浏览器原生不支持的高级语法和特性，通过 Babel 等工具自动转译为兼容代码。
- 能够实现**代码分割**和**按需加载**，让页面只加载所需的代码，提升加载速度和用户体验。

