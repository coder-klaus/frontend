ECMAScript module 简称 ESM ，是 ES6开始推出的官方模块化方式



## 基本使用

**目录结构**

```shell
.
├── index.html
├── main.js
└── math.js
```



**math.js**

```js
// 一旦使用ESM，对应脚本就会自动开启严格模式
const add = (a, b) => a + b
const sub = (a, b) => a - b

// 使用 export 导出多个变量
// 使用 {} 导出多个标识符，这是ESM语法，不是对象的简写方式
export { add, sub }
```



**main.js**

```js
// 导入模块
// 1. ESM不会自动取识别模块的扩展名，所以需要手动添加
// 2. 导入模块分为具名导入和默认导入，可以通过 {} 来加载具名导入 「 这不是对象的解构赋值 」
import { add, sub } from './math.js'

console.log(add(1, 2))
console.log(sub(1, 2))
```



**index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 使用 type="module" 来指定模块 -->
  <!-- 此时加载的JavaScript就会被当做模块文件进行解析 -->
  <!-- 浏览器的CORS策略规定，浏览器只能加载同源ESM模块  -->
  <!-- 如果直接通过file协议访问文件，origin会被视作null，从而被浏览器阻止  -->
  <!-- 这也就意味着对于浏览器而言，模块加载只能通过 http 或 https，不能通过file  -->
  <script src="main.js" type="module"></script>
</head>
<body></body>
</html>
```



## 重命名

```js
const add = (a, b) => a + b
const sub = (a, b) => a - b

// 具名导出, 并重命名
// 所以这是ESM的语法，不是对象的简写方式 => 否则无法重命名
export {
  add as addFn,
  sub as subFn
}
```

```js
// 具名导入
// 1. 具名导入的变量名必须与导出的变量名相同
// 2. 具名导入也可以通过 as 重命名，重命名后将只能使用重命名后的变量名，无法使用原变量名
//    更倾向在导入时起别名，而不是导出时
import { addFn as add, subFn as sub } from './math.js'

console.log(add(1, 2))
console.log(sub(1, 2))
```



## export

```js
// 可以在定义语句之前使用 export 导出
// 此时也是具名导出，但是export实现的具名导出，在导出时，无法重命名
export const add = (a, b) => a + b
export const sub = (a, b) => a - b
```



## 导入整个模块

```js
// 通过 * 统一导入整个模块，并通过as重命名
// 此时导入的内容本质是一个对象，对象的属性名就是模块中导出的变量名
import * as math from './math.js'

console.log(math.add(1, 2))
console.log(math.sub(1, 2))
```

