在 ESM（ES模块）中，导入的变量是“活的绑定”，只能通过导出方修改，导入方会**实时感知到变量的变化**，但**不能直接赋值修改**导入的变量，否则会报错。

`foo.js`

```js
export let msg = 'hello world'

setTimeout(() => {
  msg = 'hello world 2'
}, 1000)
```



`main.js`

```js
import { msg } from './foo.js'

console.log(msg) // hello world

setTimeout(() => {
  console.log(msg) // hello world 2
}, 1500)

// msg = 'hello world 3' // 报错，不能修改
```

刚开始打印 `hello world`，1.5 秒后打印变为 `hello world 2`。这就是 ESM 的“单向实时感知”特性。





而CJS导入内容本质是`module.exports`的同一个地址引用，所以其不是活的绑定，而是相同引用。所以既可以从导出模块修改导入模块状态，也可以通过导入模块修改导出模块

`foo.js`

```js
exports.msg = 'hello world'

exports.user = {
  name: 'John',
  age: 20
}

setTimeout(() => {
  exports.msg = 'hello world 2'
  exports.user.name = 'Jane'
}, 1000)

setTimeout(() => {
  console.log(exports.msg) // hello world 3
  console.log(exports.user.name) // Klaus
}, 2500)
```

`main.js`

```js
// 如果直接解耦使用，对于普通数据类型是简单的值拷贝，而不是引用赋值，此时对应值不会实时更新
const foo = require('./foo.js')

console.log(foo.msg) // hello world
console.log(foo.user.name) // John

setTimeout(() => {
  console.log(foo.msg) // hello world 2
  console.log(foo.user.name) // Jane
}, 1500)

setTimeout(() => {
  foo.msg = 'hello world 3'
  foo.user.name = 'Klaus'
}, 2000)
```

