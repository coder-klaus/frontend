ES Module 的解析过程可以分成三个阶段：

1. **构建阶段**（Construction）
2. **实例化阶段**（Instantiation）
3. **求值阶段**（Evaluation）



## 构建阶段

解析时根据路径去服务器下载对应资源，并为其生成一个  **模块记录**（Module Record）。

 **模块记录**（Module Record）中包括了模块的一些基本信息，一个JavaScript模块对应一个 **模块记录**（Module Record）

虽然进行静态分析，识别其中的  import 和 export 语句

此时并不执行模块代码，只生成模块记录并分析对应的  import 和 export 语句，因此是静态分析

![image-20250706200509027](https://s2.loli.net/2025/07/06/sNYeAQR1moKzhD8.png) 

在这个过程中，会存在**模块映射表**（Module Map），其中记录这模块路径和模块记录之间的映射关系，主要目的是为了避免模块的重复下载

换句话来说，ESM模块会先并行下载所有使用到的模块， 而不是像CJS那样串行下载，因此更适合在浏览器端使用



## 实例化阶段

依次解析模块记录和下载后的模块文件，在这个过程中为每个模块记录生成 **环境记录（Module Environment Record）**

在 模块环境记录中 只存在该模块导出的标识符，且是未赋值状态

并且只有导出的变量会进入模块环境记录，非导出的变量只存在于模块内部作用域，不能被其他模块访问。

例如模块`foo` 导出了`name`和`sayHello`, 于是其模块环境记录如下

```js
foo.js Module Environment Record:
{
  name: <uninitialized>,
  sayHello: <uninitialized>
}
```



生成模块环境记录后，浏览器还会建立模块之间的**绑定关系**，即导入标识符的环境记录和导出标识符的模块环境记录中建立对应通道

![image-20250706201136550_.png](https://s2.loli.net/2025/07/06/OebEWKVtRkXldQ9.png) 

此外这个连接通道是单向的，这就从语法层面上确保了导入的标识符是类似于只读的，

但实际上导出标识符的模块可以实时进行更新，导入模块会“感知到”变化，这就是所谓“实时绑定”。

```js
// main.js
import { counter } from './counter.js';
counter = 100; // 错误！不能重新赋值
```



## 求值阶段

根据之前生成的模块依赖关系图，开始执行模块代码，此时才会实际执行对应模块代码，为模块环境记录中的标识符求值

于是之前`foo`模块对应的模块环境记录变为

```js
foo.js Module Environment Record:
{
  name: 'FOO',
  sayHello: [Function: sayHello]
}
```


