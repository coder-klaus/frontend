在运行 Node 程序时，会启动一个进程。每当进程打开一个资源（如文件、网络连接等），操作系统都会为其分配一个唯一的标识符，便于后续对该资源的操作。

+ 类Unix系统 「 Mac、Linux 」中，这种标识符叫做**文件描述符**（File Descriptor，缩写为 `fd`），它是一个整数值，用于唯一标识进程打开的每一个资源。
+ **在 Windows 系统中**，操作系统为资源分配的是**文件句柄**（File Handle，缩写为 `fh`）,  它是一个对象值



如果我们要获取文件描述符，可以通过`open`等底层方法

```js
import fs from 'node:fs';

// open方法是 writeFile 和 readFile 等API底层调用的方法
// + 调用 open 方法后，会返回一个文件描述符
// + open是底层方法，不会自动关闭，直到进程结束或手动关闭
//   而Node作为服务器代码，一般7 * 24 不关机，因此需要手动通过 close 方法关闭，否则容易导致内存泄露
fs.open('./data.txt', (err, fd) => {
  // 非Promise方式获取文件描述符，得到的是一个数值
  console.log(fd) // 13

  // 拿到文件描述符后可以进行各种操作 「 以获取文件元信息为例 」
  // fstat 方法可以获取文件的元信息 「 参数必须是文件描述符 」
  fs.fstat(fd, (err, stats) => {
    console.log(stats)

    fs.close(fd, (err) => {
      console.log('文件已关闭')
    })
  })
})
```

```js
import fs from 'node:fs/promises';

const fh = await fs.open('./data.txt')

// 如果通过异步Promise方法获取文件描述符，得到的是一个文件描述符对象 「 文件句柄 」
console.log(fh)

// 同样模拟获取文件元信息
const stats = await fh.stat('./data.txt')
console.log(stats)

// 关闭文件描述符
fh.close()
```



不过实际应用情况下，我们很少去操作文件描述符，而是使用Node基于文件描述符操作封装的高级API

```js
// 获取文件描述符
import fs from 'node:fs/promises';

// 1. stats 获取文件元信息 => 参数只能是文件路径
// 2. 底层调用 open 方法获取文件描述符，然后通过 fstat 方法获取文件元信息，然后关闭文件描述符
//    所以我们不需要手动关闭文件描述符，避免了内存泄漏的风险
const stats = await fs.stat('./data.txt')

console.log(stats)
```

