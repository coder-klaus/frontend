## 判断文件或目录是否存在

```js
import fs from 'node:fs/promises';

try {
  // access 可以判断 文件或目录 是否存在
  // 如果存在，则不报催
  // 否则，会直接抛出异常
  await fs.access('./data.txt')
} catch (err) {
  console.log(err)
}
```



## 新建目录

```js
import fs from 'node:fs/promises';

// 创建目录
// 1. 默认情况下，只能创建一层目录
// 2. 加上 recursive: true 后，可以创建多层目录 「 递归创建 」
await fs.mkdir('./foo/bar', { recursive: true })
```



## 删除目录

```js
import fs from 'node:fs/promises';

// 删除目录
// 1. 即可以删除目录也可以删除文件
// 2. 可以通过 recursive: true 开启递归删除
// 3. 可以使用 fs.rmDir 来删除目录，但其不能删除文件，且未来将被废弃
await fs.rm('./foo', { recursive: true })
```



## 读取目录

假设`foo`目录下文件结构如下

```js
.
├── bar
│   └── bar.txt
└── foo.txt
```



```js
import fs from 'node:fs/promises';

const files = await fs.readdir('./foo')
// 1. 获取的是字符串数组
// 2. 只能获取一层，不能获取多层
console.log(files) // [ 'bar', 'foo.txt' ]
```

```js
import fs from 'node:fs/promises';

const files = await fs.readdir('./foo', { withFileTypes: true })

// 加上 withFileTypes 后，返回的是 Dirent 对象
// 可以通过 Dirent 对象的 isDirectory 方法判断是否是目录
// 可以通过 Dirent 对象的 name 获取文件名
console.log(files)
/* 
=>
  [
    Dirent { name: 'bar', parentPath: './foo', Symbol(type): 2 },
    Dirent { name: 'foo.txt', parentPath: './foo', Symbol(type): 1 }
  ]
*/
```



此时我们就可以自己手动通过递归的方式遍历目录结构

```js
import fs from 'node:fs/promises';

async function readDir(path, prefix = ' ') {
  const files = await fs.readdir(path, { withFileTypes: true })

  for (const file of files) {
    if (file.isDirectory()) {
      console.log(`${prefix}${file.name}`)
      await readDir(`${path}/${file.name}`, `${prefix}  `)
    } else {
      console.log(`${prefix}${file.name}`)
    }
  }
}

readDir('./foo')
/*
  bar
    bar.txt
  foo.txt
*/
```



## 改名

和 类Unix系统 的 `mv` 指令类似，Node中的`rename`方法既可以改文件和目录的名称，也可以进行剪切操作

其本质是基于源生成一个目标文件或目录，再移除源

```js
import fs from 'node:fs/promises';

// rename 进行 重命名或剪贴操作时，对应文件和目录必须存在，否则报错

// 剪贴
await fs.rename('./foo/bar/baz.txt', './foo/baz.txt')

// 重命名
await fs.rename('./foo/baz.txt', './foo/bar.txt')
```

