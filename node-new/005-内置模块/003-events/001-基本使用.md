Node的大多数API（如 http、stream）都基于事件驱动机制实现。

Node将事件绑定功能独立封装在 `events` 模块中，其它模块通过继承 `events` 模块，从而保证了大部分内置模块都能使用统一的事件绑定方式。

```js
import { EventEmitter }  from 'events'

// 初始化事件触发器实例
const emitter = new EventEmitter()

// 监听自定义事件
emitter.on('customEvent', (name, age) => {
  console.log(name, age)
})

// 触发自定义事件
emitter.emit('customEvent', '张三', 18)
```



一般情况下，我们会将所有参数整合到一个对象中进行统一传递，这个对象一般称之为`payload`对象

```js
import { EventEmitter }  from 'events'

// 初始化事件触发器实例
const emitter = new EventEmitter()

// 监听自定义事件
emitter.on('customEvent', payload => {
  console.log(payload)
})

// 触发自定义事件
emitter.emit('customEvent', {
  name: 'Klaus',
  age: 18
})
```



## 移除监听

```js
import { EventEmitter }  from 'events'

const emitter = new EventEmitter()

const handler = payload => console.log(payload)

emitter.on('customEvent', handler)

// 触发自定义事件
emitter.emit('customEvent', 'Klaus')

// 移除事件监听 => 回调函数引用地址必须相同
emitter.off('customEvent', handler)

// 此时该事件监听不会被触发
emitter.emit('customEvent', 'Alex')
```

```js
import { EventEmitter } from 'events'

const emitter = new EventEmitter()

emitter.on('customEvent1', () => { console.log('handler1') })
emitter.on('customEvent2', () => { console.log('handler2') })

// 移除所有事件监听器
emitter.removeAllListeners()

// 什么都不会打印，无事发生
emitter.emit('customEvent1')
emitter.emit('customEvent2')
```

```js
import { EventEmitter } from 'events'

const emitter = new EventEmitter()

emitter.on('customEvent1', () => { console.log('handler1') })
emitter.on('customEvent2', () => { console.log('handler2') })

// 移除某一个具体的事件监听器
emitter.removeAllListeners('customEvent1')

emitter.emit('customEvent1') // 不被触发
emitter.emit('customEvent2') // 输出 handler2
```







事件总线虽然好用，但实际开发中要小心。它的“自由度”太高，事件从哪发出、谁在监听，可能不太好追踪，维护起来有点麻烦。不过在特定场景下，它特别实用，比如处理流数据

1. path
2. process
3. 常见请求头和响应头
4. 强缓存和协商缓存



