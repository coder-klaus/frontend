## 同步流程

### Express

```js
import express from 'express'

const app = express()

// 可以认为 中间件的执行流程是 深度优先的
// 整体执行流程如下:
// 中间件1 => 中间件1的next() => 中间件2 => 中间件2的next() => 中间件3
// => 中间件2中next()后续代码 => 中间件1中next()后续代码 => 响应结果
// 所以最终向客户端返回结果为 abc
app.use((req, res, next) => {
  res.msg =  'a'
  next()
  res.send(res.msg)
})

app.use((req, res, next) => {
  res.msg +=  'b'
  next()
})

app.use((req, res, next) => {
  res.msg +=  'c'
})

app.listen(3000)
```



### Koa

```js
import Koa from 'koa'

const app = new Koa()

// Koa 就同步代码执行流程而言，和 Express 是完全一致的
app.use((ctx, next) => {
  ctx.msg = 'a'
  next()
  ctx.body = ctx.msg
})

app.use((ctx, next) => {
  ctx.msg += 'b'
  next()
})

app.use((ctx, next) => {
  ctx.msg += 'c'
  next()
})

app.listen(3000)
```





## 异步流程

### Express

`Express` 的 `next`方法返回值是 `void`，其中间件无法回溯，只能以直线的方式交给下一个中间件继续执行，这种执行方式被称之为`瀑布流`

```js
import express from 'express'

const app = express()

// 模拟异步请求
const sleep = (ms = 1500) => new Promise(resolve => setTimeout(resolve('sleep'), ms));

app.use((req, res, next) => {
  res.msg = 'a'
  // Express 的 next() 的返回值是 void，无法等待异步中间件执行完成后再执行后续操作
  next()
  // 最终响应结果为 abc
  res.send(res.msg)
})

app.use((req, res, next) => {
  res.msg += 'b'
  next()
})

app.use(async (req, res, next) => {
  res.msg += 'c'

  const sleepRes = await sleep()

  res.msg += `-${sleepRes}`
})

app.listen(3000)
```

如果要使用异步处理结果，则需要再异步中间件后边再加上一个额外的中间件进行处理

```js
import express from 'express'

const app = express()

// 模拟异步请求
const sleep = (ms = 1500) => new Promise(resolve => setTimeout(resolve('sleep'), ms));

app.use((req, res, next) => {
  res.msg = 'a'
  next()
})

app.use((req, res, next) => {
  res.msg += 'b'
  next()
})

app.use(async (req, res, next) => {
  res.msg += 'c'

  const sleepRes = await sleep()

  res.msg += `-${sleepRes}`
  next()
})

// 额外添加的中间件，用于处理异步请求结果
app.use((req, res) => {
  // 最终响应结果为 abc-sleep
  res.send(res.msg)
})

app.listen(3000)
```

此外

```js
import express from 'express'

const app = express()

const sleep = (ms = 1500) => new Promise(resolve => setTimeout(resolve, ms));

app.use((req, res, next) => {
  res.msg =  'a'
  next()
  // 最终响应结果为 ab
  res.send(res.msg)
})

app.use(async (req, res, next) => {
  res.msg +=  'b'
  await sleep(1000)
  // await 后边的内容，相当于放到了异步promise的then回调中
  // express的next方法返回的是undefined，无法等待异步处理完毕
  // 此时会直接执行主线程后续逻辑，即第一个中间件的res.send方法，向客户端发出响应
  next() // 异步执行完毕，依旧会触发next方法，但是响应流已经结束，已经不存在后续中间件了，于是静默失效，无事发生
})

app.use((req, res, next) => {
  res.msg +=  'c'
})

app.listen(3000)
```



### Koa

Koa 的 `next` 方法返回一个 Promise，因此我们可以通过 `await next()` 等待下一个中间件及其后续全部执行完毕后，再执行当前中间件的后续代码。

这就像剥洋葱一样，先一层层进入到最内层，然后再一层层返回外层。Koa 这种中间件执行模型被称为“洋葱模型”，其本质是一种递归执行流程。

基于洋葱模型，我们可以在 `await next()` 之前处理请求相关逻辑（如参数校验、鉴权等），在 `await next()` 之后处理响应相关逻辑（如设置响应头、格式化返回数据等）。

虽然 Koa 的洋葱模型允许在 `await next()` 前后分别处理请求和响应逻辑，但实际开发中，大多数中间件还是采用“单一职责”的方式，每个中间件只做一件事，这样更直观、更易于维护。

![img](https://s2.loli.net/2025/06/23/3WRoPgExMadvbeA.png) 

```js
import Koa from 'koa';

const app = new Koa();

// 模拟异步请求
const sleep = (ms = 1500) => new Promise(resolve => setTimeout(resolve('sleep'), ms));

app.use(async (ctx, next) => {
  ctx.msg = 'a'
  await next()
  // 最终响应结果为 abc-sleep
  ctx.body = ctx.msg
});

app.use(async (ctx, next) => {
  ctx.msg += 'b'
  // Koa 的 next() 返回 promise实例，可以通过await等待异步中间件执行完成
  await next()
});

app.use(async (ctx, next) => {
  ctx.msg += 'c'
  const res = await sleep()
  ctx.msg += `-${res}`
  // 因为没有下一个中间件了，所以这一句等于什么都没有做
  await next()
});

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});
```



## 总结

+ 对于同步代码，Koa 和 Express 的中间件执行流程都满足 洋葱模型
+ 对于异步代码
  + Koa 的 中间件 可以通过 async/await 来让 中间件执行流程 遵循 洋葱模型
  + 而对于 Express，中间件执行流程只能是瀑布式的单向执行，无法遵循 洋葱模型
