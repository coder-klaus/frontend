早期 `Koa` 使用的 路由是`koa-router`。不过`koa-router`已经不再维护了，目前使用的路由库是`@koa/router`



## 简单使用

```js
import Koa from 'koa'
import Router from '@koa/router'

const app = new Koa()

// 创建路由 「 不传参，则默认前缀为 / 」
const router = new Router()

// 此时就可以一次注册多个中间件了
// 通用中间件
router.use(
  (ctx, next) => { console.log(1); next() },
  (ctx, next) => { console.log(2); next() },
  (ctx, next) => { console.log(3); next() }
)

// 路径中间件
router.use('/',
  (ctx, next) => { console.log('one'); next() },
  (ctx, next) => { console.log('two'); next() },
  (ctx, next) => { console.log('three'); next() }
)

// 路由中间件
router.get('/',
  (ctx, next) => { console.log('get1'); next() },
  (ctx, next) => { console.log('get2'); next() },
  (ctx, next) => { console.log('get3'); ctx.body = 'Hello World' }
)

/*
 控制台输出的日志为:
 1
 2
 3
 one
 two
 three
 get1
 get2
 get3
 并最终返回 Hello World
*/

// 使用路由中间件
app.use(router.routes())

app.listen(3000, () => {
  console.log('Server is running on port 3000')
})
```



## 路由驱动机制

```js
import Koa from 'koa'
import Router from '@koa/router'

const app = new Koa()

const router = new Router()

router.use(
  (ctx, next) => { console.log(1); next() },
  (ctx, next) => { console.log(2); next() },
  (ctx, next) => { console.log(3); next() }
)

// 路径中间件
router.use('/',
  (ctx, next) => { console.log('one'); next() },
  (ctx, next) => { console.log('two'); next() },
  (ctx, next) => { console.log('three'); ctx.body = 'Hello World' }
)

/*
  此时控制台什么都没有输出，且最终返回 Not Found

  在 Koa Router 中，无论是通用中间件还是路径中间件，只有在有具体路由被匹配时才会依次执行。
  如果没有匹配到具体的路由中间件，这些中间件（即使路径和条件匹配）也不会被执行。

  这和 Express 的机制不同：
  + Express 的通用中间件，只要路径匹配，不管是否有后续路由或方法匹配，都会执行。
  + Express 的路径中间件，只要路径匹配，也会执行，不关心请求方法。

  因此，可以认为 Koa Router 是“路由驱动”的中间件机制，只有路由匹配后，相关中间件才会被触发。
*/

// 使用路由中间件
app.use(router.routes())

app.listen(3000, () => {
  console.log('Server is running on port 3000')
})
```



## 路由中间件

```js
import Koa from 'koa'
import Router from '@koa/router'

const app = new Koa()
const router = new Router()

router.get('/', (ctx, next) => {
  ctx.body = 'Hello World'
})

// 只注册路由中间件
app.use(router.routes())

app.listen(3000, () => {
  console.log('Server is running on port 3000')
})
```

此时，如果访问未注册的路径（如 `GET /notfound`），或使用未允许的方法（如 `POST /`），Koa 都会返回 `404 Not Found`。

也就是说，**路径不匹配**和**方法不匹配**都会统一返回 404，无法区分到底是路径不存在还是方法不被允许，这对排查问题不太友好。

![image.png](https://s2.loli.net/2025/07/01/zkQWIvF75GfMAVy.png)  

为了区分这两种情况，可以在 `router.routes()` 后加上 `router.allowedMethods()`

```js
import Koa from 'koa'
import Router from '@koa/router'

const app = new Koa()
const router = new Router()

router.get('/', (ctx, next) => {
  ctx.body = 'Hello World'
}

// 注册路由和方法中间件
app.use(router.routes()).use(router.allowedMethods())

app.listen(3000, () => {
  console.log('Server is running on port 3000')
})
```

此时：

- **路径不存在**时，返回 `404 Not Found`
- **路径存在但方法不被允许**时，返回 `405 Method Not Allowed`，并自动在响应头添加 `Allow` 字段，列出允许的方法

这样可以更清晰地区分“路由不存在”和“请求方法不被允许”，便于调试和排查问题。

![image.png](https://s2.loli.net/2025/07/01/rYC3SykcsaHbuod.png) 



## 自动挂载路由

### 目录结构

```shell
├── main.js
└── routers
    ├── home.js
    └── user.js
```



### 路由文件示例 「 以 `home.js` 为例 」

```js
import Router from '@koa/router'

// 通过 prefix 设置路由前缀
const router = new Router({ prefix: '/home' })

// 和 Express一样，子路由必须是绝对路径，不能是相对路径
router.get('/', (ctx, next) => {
  ctx.body = 'Hello home'
})

export default router
```



### 主入口文件 「 `main.js` 」

```js
import Koa from 'koa'
import path from 'node:path'
import fs from 'node:fs/promises'
import { fileURLToPath } from 'node:url'

const app = new Koa()
const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

async function registerRouter(app) {
  // 读取 routers 目录下的所有文件
  const files = await fs.readdir(path.join(__dirname, 'routers'), { withFileTypes: true })

  // 遍历所有文件并取出路由文件
  files.forEach(async (file) => {
    if (!file.isDirectory() && path.extname(file.name) === '.js') {
      // 导入路由文件，并获取默认导出的路由对象
      const { default: router } = await import(`./routers/${file.name}`)
      // 注册路由和方法检测工具
      app.use(router.routes()).use(router.allowedMethods())
    }
  })
}

registerRouter(app)

app.listen(3000, () => {
  console.log('Server is running on port 3000')
})
```
