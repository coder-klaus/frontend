数据库驱动是一个第三方库，借助它我们可以在代码中编写 SQL 语句，将其发送给数据库执行，并将处理结果返回给程序。

Node.js里有两个常用的数据库驱动库：`mysql`和`mysql2`。

+ `mysql`是最早的驱动，但已经停止维护，不再更新
+ `mysql2`是在`mysql`基础上优化改进的，性能更好，功能更强大



## JSON_OBJECT

当我们通过数据库驱动去查询MySQL时，返回的结果将会是一个对象数组，每个对象对应数据库中的一行记录。

假设执行如下SQL语句

```sql
SELECT 
	orders.id AS oid, 
	product, 
	amount, 
	customer_id, 
	customers.id as cid, 
	customer_name 
FROM orders 
INNER JOIN customers 
ON orders.customer_id = customers.id;
```



查询到的结果如图所示

![image-20250630152416368](https://s2.loli.net/2025/06/30/OkjNWr4MJcdzGwo.png) 



则`MySQL2`默认返回的数据结构类似于 「 仅显示前面两条，后续省略 」

```js
[
  {
    oid: 1,
    product: '手机',
    amount: 2999.00,
    customer_id: 1,
    cid: 1,
    customer_name: '张三'
  },
  {
    oid: 3,
    product: '平板',
    amount: 1999.00,
    customer_id: 1,
    cid: 1,
    customer_name: '张三'
  },
  // ...
]
```



此时每个表的字段都是同级属性，虽然可行，但不够直观。我们很多时候，其实希望返回的是嵌套结构，此时就可以使用`JSON_OBJECT`

> **`JSON_OBJECT`** 用来把**同一行的多个字段**，整合成一个 JSON 对象。
>
> `JSON_OBJECT`是普通函数，不是聚合函数

```sql
SELECT 
	orders.id AS oid, 
	product, 
	amount, 
  JSON_OBJECT(
    -- key, value
		'customer_id', customer_id, 
		'cid', customers.id, 
		'customer_name', customer_name
	) AS customer
FROM orders 
INNER JOIN customers 
ON orders.customer_id = customers.id;
```

此时查询结果如下 「 其中`customer`字段值类型就是`JSON` 」

![image-20250630153045989](https://s2.loli.net/2025/06/30/YcijtWvG48RlJAg.png) 

`MySQL2`默认返回的数据结构类似于

```js
[
  {
    oid: 1,
    product: '手机',
    amount: 2999.00,
    customer: {cid: 1, customer_id: 1, customer_name: "张三"}
  },
  {
    oid: 3,
    product: '平板',
    amount: 1999.00,
    customer: {cid: 1, customer_id: 1, customer_name: "张三"}
  },
  // ...
]
```

当然查询完毕后，通过代码进行数据处理也是可以的。但是数据库本身就是用来进行数据CRUD的，性能和效率要远比通过代码操作来着高效



## JSON_ARRAYAGG

假设执行如下SQL语句后

```sql
SELECT * 
FROM students AS s 
JOIN student_course AS sc ON s.student_id = sc.student_id
JOIN courses AS c ON sc.course_id = c.course_id;
```

会发现查询结果如下

![image-20250630155228944](https://s2.loli.net/2025/06/30/3DIH8mKflCOZaXn.png) 

最终返回的JSON格式为

```js
[
  { student_id: 1, name: 'Alice', student_id: 1, course_id: 102, course_id: 102, course_name: 'English' },
  { student_id: 1, name: 'Alice', student_id: 1, course_id: 101, course_id: 101, course_name: 'Math' },
  { student_id: 2, name: 'Bob', student_id: 2, course_id: 101, course_id: 101, course_name: 'Math' }
]
```



此时会发生，存在多条`name`为`Alice`的记录，我们希望将其整合为数组格式，此时就可以使用`JSON_ARRAYAGG`

```sql
-- 按学生ID分组后，只能直接查询组内所有记录都相同的字段，比如学生ID、学生姓名等
-- 对于组内值不唯一的字段，需借助聚合函数获取
SELECT
	s.student_id,
	s.name,
	-- 会将参数整合为数组形式后再返回
	JSON_ARRAYAGG(
	  JSON_OBJECT(
		  'course_name', c.course_name,
			'course_id', c.course_id
		)
	) AS courses
FROM students AS s 
JOIN student_course AS sc ON s.student_id = sc.student_id
JOIN courses AS c ON sc.course_id = c.course_id
-- 根据学生ID进行分组
GROUP BY s.student_id;
```

此时查询结果就变成了

![image-20250630155510276](https://s2.loli.net/2025/06/30/s7LOAiBNEM8r4S1.png) 

对应返回的JSON格式为

```js
[
  {
    student_id: 1,
    name: 'Alice',
    courses: [{course_id: 102, course_name: "English"}, {course_id: 101, course_name: "Math"}]
  },
  {
    student_id: 2,
    name: 'Bob',
    courses: [{course_id: 101, course_name: "Math"}]
  }
]
```



注意, 不能直接执行如下SQL语句

```sql
SELECT *
FROM students AS s 
JOIN student_course AS sc ON s.student_id = sc.student_id
JOIN courses AS c ON sc.course_id = c.course_id
GROUP BY s.student_id;
```

此时会报错的，因为根据ID分组后，`Alice`存在多条不同的课程记录，SQL并不知道如何进行处理

再简单一点说，使用 使用 `GROUP BY` 就一定会使用聚合函数，而 `JSON_ARRAYAGG`就是聚合函数



### JSON_ARRAYAGG 和 JSON_ARRAY

假设执行

```sql
SELECT * FROM students;
```

存在如下数据

![image-20250630161623241](https://s2.loli.net/2025/06/30/K2mwu4lRtbXdG1U.png) 



执行 

```sql
SELECT 
	JSON_ARRAYAGG(student_id) AS ids,
	JSON_ARRAYAGG(name) AS names
FROM students;
```

![image-20250630161827120](https://s2.loli.net/2025/06/30/S3A6RFtodIT1M2h.png) 

说明 `JSON_ARRAYAGG`是一个聚合函数，用于将多列数据整合为一个JSON格式数组



执行

```sql
SELECT 
	JSON_ARRAY(students.student_id, students.name) AS stu_infos
FROM students;
```

![image-20250630162207431](https://s2.loli.net/2025/06/30/8h7dtJrCxbn1VDF.png) 

说明 `JSON_ARRAY` 是一个普通功能函数，用于将同一条记录的多个字段值转换为JSON数组。

