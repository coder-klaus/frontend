预处理语句（Prepared Statements）有两个主要好处：

1. **提高性能**：可以让SQL语句执行更快。
2. **防止SQL注入**：提高安全性，避免黑客通过恶意输入攻击数据库。



## 提升性能

执行一条SQL语句会执行如下流程:

1. 解析 SQL 语句，检查语法是否正确
2. 校验数据库、数据表、字段是否存在，以及用户是否有相应权限
3. 进行查询优化，选择最优的执行计划
4. 根据执行计划，调用存储引擎进行实际的数据操作
5. 返回执行结果给客户端

在实际业务中，某些SQL语句可能会被重复多次执行，仅参数不同。如果每次都完整经历“解析、校验、优化、生成执行计划”等步骤，会造成不必要的性能开销。

为此，可以使用**预处理语句（Prepared Statement）**。其工作流程如下：

1. **首次执行时**，数据库会对SQL语句进行解析和优化，生成并保存执行计划，其中参数部分用占位符表示。
2. **后续再次执行**时，只需将实际参数绑定到占位符，直接复用之前生成的执行计划，无需重复解析和优化。

这样，预处理语句可以显著减少SQL多次执行时的编译和优化开销，从而提升整体性能。预处理语句特别适合于结构相同、参数不同的高频SQL场景。



## SQL注入

如果使用普通SQL进行数据查询时，使用的是字符串拼接

类似于

```js
const statement = `SELECT * FROM users WHERE name = '${name}' AND password = '${password}';`
```

可以黑客就可以使用精心构造的输入 「 如 `xx' OR 1=1; --` 」来篡改SQL语句的运行逻辑

因为拼接后的执行语句为

```sql
SELECT * FROM users WHERE name = 'xxx' AND password = 'yyy' OR 1 = 1; --'
```

因为存在`OR`语句，因此密码永远是正确的



类似于这种利用字符串拼接漏洞来篡改SQL运行逻辑的攻击方式就是 SQL注入



而 预处理语句是编译后的SQL模板，动态值通过`?`来进行占位

在执行时，预处理语句会被预编译，用户输入的内容只作为参数绑定到`?`上，无论输入中包含什么内容，都只会被当作普通数据处理，无法改变SQL语句的结构和逻辑，从而在最大程度上防止SQL注入。

```sql
SELECT * FROM users WHERE name = ? AND password = ?;
```



## 基本使用

```js
import mysql from 'mysql2';

const connection = mysql.createConnection({
  host: 'localhost',
  user: 'root',
  password: 'P@ssw0rd',
  database: 'demo_db'
})

// 预处理语句使用 ? 作占位符
const statement = 'SELECT * FROM orders WHERE amount >= ?;';

// 普通语句通过query方法执行，而预处理语句使用 execute 方法执行
// 参数二是一个数组，数组中的元素会依次替换预处理语句中的 ? 占位符
connection.execute(statement, [2000], (err, results, fields) => {
  console.log('results', results);
  /*
    results [
      { id: 1, product: '手机', amount: '2999.00', customer_id: 1 },
      { id: 2, product: '笔记本', amount: '6000.00', customer_id: 2 }
    ]
  */
  console.log('fields', fields);
  /*
    fields [
      `id` INT NOT NULL PRIMARY KEY,
      `product` VARCHAR(50),
      `amount` DECIMAL(10,2),
      `customer_id` INT
    ]
  */
})

connection.end();
```

