字节是计算机中存储数据的基本单位。比如存储数字1时，底层实际上会用一个字节来存储，而不是仅用一位。

这样做的目的是为了统一存储方式，便于后续处理。

在某些编程语言中

+ Java => int通常占用4个字节，long则占用8个字节
+ JavaScript => number 通常采用8个字节进行存储



直接操作二进制很不方便，为此 node.js 提供了操作二进制的全局类 Buffer

+ Buffer 主要用于处理二进制数据，比如音频、视频、图片等资源。
+ Buffer 是一个全局类，不属于内置模块，可以直接使用，无需引入。

+ Buffer 可以理解为一个二进制字节数组，数组中的每个元素是一个字节。

  + 也就是说每一项可以表示的十进制数范围为 `[0, 255]`
  + 也就是说一个字节最多可以表示 256个数字

+ Buffer 本质是 `Uint8Array` 的实例

  + JavaScript 为了方便我们操作二进制，提供了一系列存储二进制的数组类

    + `Uint8Array` => 每一位是 8位 无符号整数
    + `Int8Array` => 每一位是 8位 有符号整数
    + `Uint16Array` => 每一位是 8位 无符号整数
    + 。。。。

    这一系列对象有一个通用的名称 叫  TypedArray 家族 「 可以看成是伪数组 」

    + `TypedArray` 只是一个规范，不是一个可以直接 new 的构造器

+ 为了方便显示，控制台在输出 Buffer 时，会将每个字节（8位二进制）直接转换为两位十六进制数进行显示。

  「 每四个字节 对应一个 十六进制数 」

  ```shell
  <Buffer 69 6d 70 6f 72 74 20 7b 20 72 65 61>
  ```



## 基本使用

```js
// Buffer已经不再推荐通过 new 来进行创建
// 因为 new Buffer(<number>) 时 会返回一个 <number> 大小的 Buffer 对象
// 这个Buffer对象的内存是未清空的，保留着之前的旧数据，而这个Buffer对象又可以直接在控制台输出
// 如果对应内存中存放这敏感信息，则会导致信息泄露

// 创建一个 Buffer 对象，内容为 "Hello World"
const buf1 = new Buffer('Hello World')
console.log(buf1) // <Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64>

// 分配一个 10 字节的 Buffer 对象
const buf2 = new Buffer(10)
console.log(buf2) // <Buffer 00 00 00 00 00 00 00 00 00 00>
```

```js
// 基于字符串创建一个 Buffer 对象，推荐使用 Buffer.from() 方法
const buf = Buffer.from('Hello World')

console.log(buf) // <Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64>

// 通过 toString() 方法将 Buffer 对象转换为字符串
console.log(buf.toString()) // Hello World
```

```js
// Buffer.alloc(<number>) 方法用于替代原本的 new Buffer(<number>) 方法
// 因为 Buffer.alloc(<number>) 方法在创建 Buffer 对象时，会自动将内存初始化为 0
const buf = Buffer.alloc(10)

console.log(buf) // <Buffer 00 00 00 00 00 00 00 00 00 00>
```

```js
// new Buffer(<number>) 底层其实调用的是 Buffer.allocUnsafe(<number>)
// 在分配内存空间的时候，不会清空内存空间，所以可能会包含敏感信息
const unsafeBuf = Buffer.allocUnsafe(10)

console.log(unsafeBuf) // <Buffer 00 00 00 00 00 00 00 00 00 00>
```

```js
const buf = Buffer.alloc(8);

// 设置字节值 => 任意进制都可以，Buffer 会自动转换为十六进制
buf[0] = 100;     // 把第0个字节设置为100（十进制）
buf[1] = 0x66;    // 把第1个字节设置为0x66（十六进制）

// <字符串>.charCodeAt() => 获取字符串中对应字符所对应的 UTF-16 编码值
// + 如果省略索引，则默认获取字符串的第一个字符的UTF-16编码值
// + 文件存储和网络传输一般使用 UTF-8 编码，而在JS内存中使用 UTF-16 编码
// + 浏览器 和 node 会自动在读取和设置时完成 UTF-16 和 UTF-8 之间的转换
// + 在 UTF-16中，中文和英文都占2个字节，部分生僻字和emoji占4个字节
// + 在 UTF-8 中，英文字符占1个字节，中文字符占3个字节，部分生僻字和emoji占4个字节
buf[2] = 'M'.charCodeAt(); // 把 M 的 UTF-16 编码值设置为第2个字节
// 英文字符编码在各个编码系统中基本相同 「 都是对应 ASCII码 」，不同的往往是中文字符。所以经常出现的其实是 中文乱码

// 输出时，对应的字节值会转换为十六进制
console.log(buf); // <Buffer 64 66 4d 00 00 00 00 00>

// 获取字节值 => 自动转换为十进制
console.log(buf[0]); // 100
console.log(buf[1]); // 102

console.log(buf.length); // 8
```

```js
const buf = Buffer.alloc(8);

// 基本语法: buf.write(string[, offset[, length[, encoding]]])
// + string: 要写入的字符串
// + offset: 开始写入的位置 「 可选 」
// + length: 写入的字节数 「 可选 」
// + encoding: 编码方式 「 可选 」

buf.write('hello', 0);

console.log(buf.toString()); // hello

buf.write('world', 5, 'utf-8');

// 申请的空间不会自动扩容
console.log(buf.toString()); // hellowor
```



一个 ASCII 字符 「 如英文字符、数字、特殊字符 」使用一位进行存储，而在`utf-8`中，一个中文使用三个字节进行存储

```js
const buf = Buffer.from('你好') // <Buffer e4 bd a0 e5 a5 bd>
console.log(buf.length) // 6
```



```js
// 创建 Buffer 时可以手动指定 编码方式，一般默认为 utf-8
// 注意: 这里的编码方式是 Node 指定的几种 「 如 ascii、utf-8、utf-16le、base64、hex 等 」
// 并不是传统意义上的字符集名称 「 如 utf-8、gbk、gb2312 等 」

// from() 方法的第二个参数是编码格式，默认是 utf-8「 可以手动指定 」
const buffer = Buffer.from('hello', 'ascii');

// Buffer实例的 toString() 方法的参数是编码格式，默认是 utf-8 「 可以手动指定 」
console.log(buffer.toString('utf-8'));
```



