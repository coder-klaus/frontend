`stream` 表示一种数据连续不断传输的方式，就像流水一样

如果数据量特别大，无法一次性读取完毕时，就可以使用流，一点点进行读取

1. 每次读取一部分字节
2. 把这些字节读取完，再读下一部分
3. 一直这样直到全部读取完成。

流的本质就是一连串被读取的**字节数据**。 当我们从文件中读取内容时，其实读到的是一堆二进制数据，而这些数据是以字节的形式被一点点传进程序里的。这种“逐字节传输”的过程，就是所谓的“流”。



`writeFile` 和 `readFile` 是**一次性**将整个文件写入或读取的方法。虽然简单，但不适合处理大文件，且缺乏灵活性。

流式读写的优势：

1. 每次仅读取部分内容。
2. 支持随时暂停 和 继续读取。
3. 读取一部分数据，处理完后再读取下一部分。
4. 避免一次性读取大文件导致的高内存占用，节省性能。



在 Node 中，其实很多对象本身就是基于流构建的，比如 HTTP 模块里的 `request` 和 `response` 对象。

所有流对象其实都是 `EventEmitter` 的实例。也就是说它们可以监听事件，并对事件做出响应。



Node 主要有四种类型的流：

> 读取和写入的源 可以是文件，也可以是 客户端

| 分类                        | 说明                                                         | 举例                   |
| --------------------------- | ------------------------------------------------------------ | ---------------------- |
| 可读流<br />「 Readable 」  | 读取内容                                                     | `fs.createReadStream`  |
| 可写流<br /> 「 Writable 」 | 写入内容                                                     | `fs.createWriteStream` |
| 双工流<br />「 Duplex 」    | 可读可写<br />常见于 socket<br />socket 是一种在客户端和服务器之间建立连接的机制，<br />相当于在两端之间建立了一条数据通道，可以双向传输数据。 | `net.Socket`           |
| 转换流<br />「 Transform 」 | 不仅能读取和写入数据，<br />还能在这个过程中对数据做一些处理或修改。 | `zlib.createDeflate`   |



