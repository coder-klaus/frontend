## query参数

```js
import http from 'node:http'
// url 是 node 内置模块，主要提供 URL 和 URLSearchParams
// URLSearchParams 使用方式和 浏览器的 URLSearchParams 完全一致
// URL 和 浏览器的URL 存在些许差异
import url from 'node:url'

// 请求方式 GET localhost:3000?name=Klaus&age=23
const server = http.createServer((req, res) => {
  res.setHeader('Content-Type', 'text/html; charset=utf-8')

  // req.url 不是完整url地址，而是 pathname + search
  console.log(req.url) // /?name=Klaus&age=23

  // parse方法 和 浏览器中的 url.parse 方法改变完全一致，两者都会将其解析为对象，但两者在细节上存在些许差异
  // 1. 浏览器解析后的对象中 href 是完整url地址，而 node 中是 pathname + search
  //    + 浏览器解析对象中有origin，而 node 中没有
  // 2. 浏览器解析后的对象中 只有search，而 node中 既有search 也有 query
  //    + 浏览器中的 search 是完整的 search 参数 「 ?name=Klaus&age=23 」
  //    + node解析对象中的search参数和浏览器中一致，都是完整的 search 参数 「 ?name=Klaus&age=23 」
  //    + node解析对象中的query是不带 ? 的 search 参数 「 name=Klaus&age=23 」
  const { pathname, query, search } = url.parse(req.url, true)
  console.log(pathname) // /

  // node中的 url.parse 方法 和 浏览器的 url.parse 方法还有一个差异就是
  // node中的 url.parse 方法 支持第二个参数，默认值为false

  // 如果第二个值为 false，则此时 query 参数会返回一个字符串 「 在本例中就是 name=Klaus&age=23 」
  // 如果第二个值为 true，则此时 query 参数会转换为对象 「 在本例中就是 { name: 'Klaus', age: '23' } 」
  console.log(query) // { name: 'Klaus', age: '23' }

  // 查询字符串，location中标准属性
  // query就是不带 ? 的 search 参数
  console.log(search) // ?name=Klaus&age=23

  // 这里严格意义上应使用 pathname 来判断
  // 因为 req.url 会包含 query 参数 不能直接通过全等进行判断
  if (pathname === '/' && req.method === 'GET') {
    res.end('你好~')
  } else {
    res.statusCode = 405
    res.end('不支持的请求方法')
  }
})

server.listen(3000)
```

> 推荐 放弃 node 提供的 url 内置模块，而是统一使用 ECMA 提供的` URL` 和 `URLSearchParams`，从而忽略两者之间的细微差异
>
> ```js
> // 浏览器的URL必须是带协议的完整路径，不能仅仅是 pathname + search
> const myUrl = new URL(req.url, `http://${req.headers.host}`);
> 
> console.log(myUrl.pathname, myUrl.searchParams.get('name'));
> ```



## body

```js
import http from 'node:http'

const server = http.createServer((req, res) => {
  res.setHeader('Content-Type', 'text/html; charset=utf-8')

  // 设置请求体的编码
  req.setEncoding('utf-8')

  if (req.url === '/login' && req.method === 'POST') {
    let body = ''


    // req和res本质都是流，所以body需要通过只读流来逐步接收
    req.on('data', (chunk) => {
      // 如果通过req.setEncoding('utf-8')设置了编码，则chunk是字符串
      // 如果未设置，则chunk是Buffer => body是字符串，buffer是Buffer，相加遵循字符串拼接 => chunk隐式转换为字符串
      body += chunk
    })

    req.on('end', () => {
      // 如果请求头中content-type为application/json，则将body转换为对象
      if (req.headers['content-type'] === 'application/json') {
        body = JSON.parse(body)
      }
      res.end(`登录成功，用户名：${body.username}，密码：${body.password}`)
    })
  } else {
    res.statusCode = 405
    res.end('不支持的请求方法')
  }
})

server.listen(3000)
```



## headers

| 请求头              | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| `Content-Type`      | 用于告诉客户端或服务器该请求或响应是什么格式数据             |
| `Cotent-Length`     | 表示当次传输数据大小                                         |
| `Connection`        | 值为 `keep-alive` 或 `close` => 即可以是请求头，也可以是响应头<br />HTTP 1.1 开始 默认开启 => 表示请求保活 => 即默认值为`keep-alive` => 可以省略<br />不同服务器保活时间不一致「 node 是 五秒 」<br />每次请求后，http会存在五秒的延续时间<br />+ 此时有新请求，会沿用之前的http通道，并重置保活时间，从而减少新建http通道的消耗<br />+ 如果保活时间结束，无新请求，则关闭之前建立的http通道 |
| `Accet-Encoding`    | 告诉服务器，用户代理支持什么格式的压缩内容<br />如果服务器支持`Accet-Encoding`中标注的压缩格式<br />则会自动将响应内容使用对应格式进行压缩，并通过`Content-Encoding`这个响应头告诉用户代理当前响应体的压缩格式<br />用户代理会自动下载后先进行解包，再进行解析 |
| `accept`            | 告诉服务器客户端希望接收哪些类型的数据                       |
| `accept-language`   | 告诉服务器客户端希望接收哪些语言版本的内容                   |
| `host`              | 请求的目标域名和端口号<br />如`www.exmaple.com:5173`         |
| `Cookie`            | cookie组成的字符串                                           |
| `User-Agent`        | 用户代理的相关信息                                           |
| `If-Modified-Since` | 值为某个具体时间<br />用户判断资源是否自指定时间后修改       |
| `If-None-Match`     | 值是某个 Etag值                                              |
| `Referer`           | 请求来源的URL<br />如`https://www.example.com/page`          |
| `Authorization`     | 请求时携带的身份凭证                                         |



| 响应头                        | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `Content-Type`                | 响应的数据类型                                               |
| `Content-Length`              | 响应体的字节长度                                             |
| `Content-Encoding`            | 响应体的压缩格式                                             |
| `Server`                      | 服务器相关信息                                               |
| `Date`                        | 响应时间                                                     |
| `Cache-Control`               | 用于实现强缓存 「 HTTP/1.1 」                                |
| `Expires`                     | 用于实现强缓存 「 HTTP/1.0 」                                |
| `ETag`                        | 资源的唯一标识，用于缓存验证                                 |
| `Last-Modified`               | 资源最后修改时间                                             |
| `Set-Cookie`                  | 服务器让用户代理“设置”或“更新”的一个`Cookie`<br />一个`Set-Cookie`只能设置一个`Cookie`。<br />如果要设置多个`Cookie`，就需要设置多个`Set-Cookie`响应头 |
| `Location`                    | 重定向的URL地址                                              |
| `Access-Control-Allow-Origin` | 跨源资源共享（CORS）的允许来源<br />`*` 表示任意源都可以<br />也可设置某一个一级域名，只有该域名下地址请求才不会跨域<br />不能设置多个域，如果需要，则需要服务器通过请求动态进行设置 |
| `Referer-Policy`              | 控制用户代理应该如何设置`Referer`的值<br />如`https`下携带完整地址，`http`下值携带域名和端口号等 |



**Set-Cooklie**

```shell
# Path 表示 Cookie 的作用路径。
# 只有请求的 URL 路径以这个 Path 开头时，浏览器才会携带这个 Cookie 给服务器。

# 例如，如果 Path=/，则：
#  + https://example.com/
#  + https://example.com/about
#  + https://example.com/user/profile
# 这些路径都会携带该 Cookie。

# 如果 Path=/user/，则：
#  + 访问 https://example.com/user/、https://example.com/user/profile 会带上这个 Cookie。
#  + 访问 https://example.com/about 就不会带上这个 Cookie。

# HttpOnly 表示 Cookie 只能让服务器通过 Set-Cookie 响应头进行设置，不能被 JavaScript（如 document.cookie）访问，避免 XSS 攻击。
Set-Cookie: token=abc123; Path=/; HttpOnly

# Secure 表示该 Cookie 只会在 HTTPS 下发送，HTTP 下不会发送。
Set-Cookie: session_id=abc123; Path=/; Secure
```



### 缓存机制

#### 协商缓存

协商缓存是用户代理每次请求资源前，先将上次资源的缓存时间以请求头的方式告诉服务器

服务器将对应资源的最后更新时间和客户端缓存的时间进行对象

+ 如果资源没有更新，返回状态码 `304 Not Modified`。直接使用缓存，节省带宽
+ 如果资源更新了，则返回状态码 `200 OK`，更新用户代理缓存资源，并更新用户代理资源缓存时间



实现方式有两种

1. `Last-Modified 和 If-Modified-Since`

   + 这是 `HTTP/1.0`时候的方式 => 为了向后兼容，目前依旧可以使用

   + 响应头写到`Last-Modified`标识资源最后修改时间

   + 用户代理缓存对应时间，下次请求时，通过`If-Modified-Since`携带对应时间给服务端

   + 服务端判断`If-Modified-Since`的值和对应资源的最后修改时间是否一致 从而判断 资源是否需要进行更新

     

2. `ETag` 和 `If-None-Match`

   + 这是 `HTTP/1.1`时候的方式
   + 响应头 `ETag` 是一段 字符串哈希值，用于标识对应版本
   + 客户端再次请求时通过`If-None-Match`携带 `ETag`值给服务端
   + 服务端通过`If-None-Match` 和 对应资源`ETag`值进行比较，判断资源是否需要进行更新



如果`Last-Modified 和 If-Modified-Since` 和 `ETag 和 If-None-Match` 同时存在，则以新版本的`ETag 和 If-None-Match`为准



#### 强缓存

强缓存是服务器直接设置一个过期时间，在这个时间范围内，用户代理直接使用之前缓存内容，不用像服务器询问资源是否过期

设置方式是通过响应头的方式告诉客户端资源使用强缓存

1. `Expires`

   + `HTTP/1.0`使用该字段实现强缓存 => 为了向后兼容，依旧可用

   ```shell
   Expires: Wed, 21 Oct 2025 07:28:00 GMT
   ```

   

2. `Cache-Control`

   + HTTP/1.1 使用该字段实现强缓存

   ```shell
   # 在一天之内之前，直接用缓存资源，不用获取新资源
   # 对应的值也是可以 no-cache 表示不使用强缓存
   Cache-Control: max-age=86400 # 86400 表示一天 「 即单位为秒 」
   ```

如果同时存在`Expires` 和 `Cache-Control` ，则以新版本的`Cache-Control`为准



### Authorization

请求头，用于在请求时携带对应身份凭据

身份凭据有很多，例如 `Basic Auth` 「 通过用户名和密码进行登录 」和 `Bearer Token` 「 `Bearer`是携带者，持有人的意思 」

其中最为常用的 `Token` 方式就是 `Bearer Token`,  其格式为

```shell
# 这个 token 可以是 JWT（JSON Web Token），也可以是 OAuth 2.0 的 Access Token，或者其它形式的Token
uthorization: Bearer <token>
```



**Postman** 等工具确实可以通过 `Authorization` 选项卡方便地选择凭据类型并设置对应的凭据。

Postman等工具最终还是会将其设置为请求头，只不过配置更方便，交互性更好。



当然我们也可以通过自定义请求头或自定义`Cookie`的方式向服务器传递`Token`

+ 一般自定义的`Cooke` 或 请求头 格式为 `x-yyy-zzz` 「 约定俗成， 非语法强制 」

+ 其中 `x`是`extend`的简写，以便于和 `普通原生请求头`和 `Cokkie` 进行区分



### content-type

| 类型                                | 说明                                          |
| ----------------------------------- | --------------------------------------------- |
| `text/plain`                        | 普通字符串                                    |
| `application/json`                  | JSON格式字符串                                |
| `application/xml`                   | XML格式字符串                                 |
| `application/x-www-form-urlencoded` | URL编码格式字符串<br />如 key=value&key=value |
| `multipart/form-data`               | 表单数据                                      |



### 常见文件压缩算法

如果 Accept-Encoding 配置了多个使用逗号分割的压缩算法，

则会从左向右进行匹配，并使用第一个匹配到的可以使用的压缩算法。

| 算法                        | 说明                                                         | 后缀         |
| --------------------------- | ------------------------------------------------------------ | ------------ |
| `deflate`<br />「 干瘪的 」 | 一种经典的压缩算法, 通常在内存中完成压缩<br />也就是说压缩后的内容仅在内存中，并不会写入某个具体文件<br />因此没有对应输出文件后缀<br />一些应用底层就是基于`defalte` 「 例如: 压缩软件`zlib` 」 | 通常无扩展名 |
| `gzip`                      | 基于 `deflate` 的压缩算法，带有文件头和校验，最常用的 HTTP 压缩格式 | `.gz`        |
| `br`（brotli）              | 新一代压缩算法，压缩率高于 gzip，<br />现代浏览器和服务器已广泛支持。但老版本浏览器兼容性相对欠佳 | `.br`        |



我们还可以在响应头中指定返回内容的编码方式，比如设置为 UTF-8，客户端就能正确识别中文内容，不会出现乱码问题。如果没设置，浏览器可能会误判编码格式，从而导致内容显示异常。
