浏览器在上传文件时，通常是通过 `input[type='file']` 选择文件，并以 `formData` 的方式进行上传。

这意味着，上传的数据本质上是由多个 `key` 和 `value` 组成的表单数据，其中只有一个 `value` 是我们实际需要的文件内容。

因此，我们需要从表单数据中提取出对应的文件二进制数据，然后再将其写入到目标文件中。

实际开发中，一般通过第三方库来完成这个操作，例如 multer



下面通过 postman 模拟文件上传的过程：

![image.png](https://s2.loli.net/2025/06/19/9pt2ZqI563weuCf.png)



```js
import http from 'node:http'
import fs from 'node:fs'
import path from 'node:path'

const server = http.createServer((req, res) => {
  if (req.method !== 'POST' && req.url !== '/upload') {
    res.statusCode = 404
    res.end('Not Found')
    return
  }
  
  // 允许一切跨域客户端访问当前资源
  res.setHeader('Access-Control-Allow-Origin', '*')

  // 识别并找出 boundary
  const boundary = req.headers['content-type'].split('=')[1].trim()

  // binary是Node特有的单字节编码，会把每个字节直接映射为一个字符，转换时不会丢失任何内容  
  // utf8/ascii会按各自规则把字节转换为字符，遇到无法转换的内容时会丢弃或替换为非法字符  
  // 所以处理二进制数据时，可以把Buffer转为binary再还原Buffer，但不能将Buffer转binary后再还原
  req.setEncoding('binary') // Buffer转Binary，方便进行数据处理

  let body = ''

  req.on('data', (chunk) => {
    body += chunk
  })

  req.on('end', async () => {
    const boundaries = body.split(`--${boundary}`)
    const avatarBoundary = boundaries.find(v => v.includes('Content-Disposition: form-data; name="avatar"'))

    // 1. 文件内容使用那种换行符，取决于生成该文件的操作系统
    // 2. http协议规则，请求头 和 请求内容 中的换行符，一律使用 \r\n 表示
    const [avatar, avatarContent] = avatarBoundary.split('\r\n\r\n')
    const filename = avatar.match(/filename="(.+\.\w+)"/)[1]
    const dirPath = path.join(process.cwd(), 'uploads')

    // fs.existsSync(dirPath) 返回的是布尔值
    // fs.promises.access(dirPath) 返回的是 promise => 目录不存在直接报错
    if (!fs.existsSync(dirPath)) {
      await fs.promises.mkdir(dirPath)
    }

    // 写入流，文件不在会新建，但目录不在则会报错
    const writeStream = fs.createWriteStream(path.join(dirPath, `${Date.now()}-${filename}`))
    // 将 binary 编码的 avatarContent 转换为 Buffer 对象
    writeStream.write(Buffer.from(avatarContent, 'binary'))
    // 写入流结束
    writeStream.end()


    res.writeHead(200, {
      'Content-Type': 'text/plain; charset=utf-8'
    })

    res.end('上传成功')
  })
})

server.listen(3000)
```



当你使用 `form-data` 上传时，请求头结构如下

`Content-Type => multipart/form-data; boundary=<calculated when request is sent>`

也就是说，`frm-data`各个字段的数据会使用 `boundary`进行分割，这个`boundary`值是发送请求时，客户端自动生成的

不同客户端生成的`boundary`格式不一定一致

```shell
# postman 生成的 boundary 示例
--------------------------191255795069250770535221

# webkit 生成的 boundary 示例
----WebKitFormBoundary7MA4YWxkTrZu0gW
```

`from-data`在传输时，会在字段开头前加上`--${boundary}`, 以分割各个字段内容

数据的最后会使用`--${boundary}--`标志数据传输完成

```shell
# 示例

------WebKitFormBoundary7MA4YWxkTrZu0gW  # 字段开始
# 字段元数据
# Content-Disposition: form-data; => 固定格式
# name="<字段名>"
Content-Disposition: form-data; name="username"

alice # 内容 「 元数据 和 内容 之间换空一行 => 即`\r\n\r\n` 」
------WebKitFormBoundary7MA4YWxkTrZu0gW  # 字段开始
# 文件内容多两个内容
# 1. filename 标识文件名
# 2. Content-Type 标识文件MIME类型
Content-Disposition: form-data; name="avatar"; filename="avatar.png"
Content-Type: image/png

<文件二进制内容>
------WebKitFormBoundary7MA4YWxkTrZu0gW-- # 数据结束
```



这也就是为什么，在发送网络请求时，除了表单以外的请求都需要加上`Content-Type`。而表单提交不需要添加`Content-Type`的原因

在表单提交时，会自动生成对应的`Content-Type`

同时如何手动设置`Content-Type`为`multipart/form-data;`时，浏览器会自动在其后添加上对应的`boundary`
