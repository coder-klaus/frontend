## 解析body

### JSON格式

```js
import express from 'express'

const app = express()

// express.json() 返回一个 express 内置的中间件
// 这个中间件的作用是 解析 JSON格式请求体

// 本质是 监听req的data和end事件
// end事件触发时，反序列化请求头并挂载到req.body上
// 随后调用 next方法 执行下一个中间件
app.use(express.json())

app.post('/login', (req, res) => {
  // 解析结果会挂载到 req.body 上，是一个对象结构数据
  console.log(req.body)
  res.send('login success')
})

app.listen(3000, () => {
  console.log('Server is running on port 3000')
})
```



### urlencode格式

```js
import express from 'express'

const app = express()

// 解析 application/x-www-form-urlencoded 格式的请求体

// 早期的express 需要使用 express.urlencoded({ extended: true })
// 因为早期express 版本默认使用 不再维护的querystring 模块
// 设置为true后，将使用 qs 模块 进行替代

// 而最新版本的express已经默认使用 qs 模块，所以需要再进行任何额外的设置
app.use(express.urlencoded())

app.post('/login', (req, res) => {
  // 解析结果会挂载到 req.body 上，是一个对象结构数据
  console.log(req.body)
  res.send('login success')
})

app.listen(3000, () => {
  console.log('Server is running on port 3000')
})
```



## 请求参数

```jsx
import express from 'express'

const app = express()

app.get('/', (req, res) => {
  // 1. 可以直接通过 req.query 获取到查询参数
  // 2. 查询参数的值都是字符串类型，需要手动进行转换
  const { offset, limit } = req.query
  res.json({
    offset,
    limit
  })
})

app.get('/:id', (req, res) => {
  // 1. 可以直接通过 req.params 获取到路由参数
  // 2. 路由参数的值都是字符串类型，需要手动进行转换
  const { id } = req.params
  res.json({
    id
  })
})

app.listen(3000, () => {
  console.log('Server is running on port 3000')
})
```



### 动态路由

```js
import express from 'express'

const app = express()

// 通过正则定义路由，从而限制传入的动态参数必须是数值, 其实就是 /:id(\\d+)
// Express4 是支持这种写法的, 然而由于 path-to-regexp（Express 底层用于路由匹配的库）进行了升级
// 已经不再支持这种正则表达式形式，因此 /:id(\\d+) 这种写法在 Express5 中会直接报错
app.get(/^\/(\d+)$/, (req, res) => {
  const id = req.params[0]
  res.json({ id })
})

app.listen(3000, () => {
  console.log('Server is running on port 3000')
})
```

所以为了可读性，更推荐的写法如下

```js
import express from 'express'

const app = express()

app.get('/:id', (req, res, next) => {
  const id = req.params.id

  // 如果 id 不是数字，则跳过该中间件
  if (!/^\d+$/.test(id)) {
    next()
  }

  console.log(id)
  res.json({ id })
})

// 兜底路由
app.use((req, res) => {
  res.status(404).json({ error: 'Not found' })
})

app.listen(3000, () => {
  console.log('Server is running on port 3000')
})

```

