## 在 vscode中 进行 node debug

![image-20250623160533661](https://s2.loli.net/2025/06/23/Mxk24jfhW1lUPSE.png) 

点击调试按钮后，会启动服务，并在断点处停止 「 运行程序后，程序会在断点处暂停 」

调试控制条的各个按钮功能类似于浏览器

![image-20250623160507782](https://s2.loli.net/2025/06/23/WidA8hPjqCosu16.png) 



编写测试逻辑

```js
import express from 'express'

const app = express()

app.use((req, res, next) => {
  req.msg = 'a'
  next()
})

app.use((req, res, next) => {
  req.msg += 'b'
  next()
})

app.use((req, res, next) => {
  req.msg += 'c'
  res.send(req.msg)
})

app.listen(3000)
```



我们在`const app = express()`处打一个断点。并点击单步调试后，

会发现调用 `express()` 其实是在执行一个叫 createApplication 的函数



```js
// Express的诞生时间比较早，所以使用的还是ES5语法
var proto = require('./application');

// createApplication 方法本质就是我们导入的 express，调用后会返回 应用实例app
function createApplication() {
  
  // 应用实例本质是一个函数 「 在JavaScript中，函数的本质就是对象 」
  // Express 给这个 app 函数对象添加了很多属性和方法，比如 app.use、app.listen。
  var app = function(req, res, next) {
    app.handle(req, res, next);
  };

  // Express 给 app 对象“混入”（mixin）了 EventEmitter 的功能，所以 app 可以触发和监听事件。
  mixin(app, EventEmitter.prototype, false);
  
  // Express 还混入了一个叫 proto 的对象，里面定义了 use、listen 等方法。
  // 这是 Express 的核心
  mixin(app, proto, false);

  // 基于原生http模块的 req 生成一个 request 对象
  app.request = Object.create(req, {
    app: { configurable: true, enumerable: true, writable: true, value: app }
  })

  // 基于原生http模块的 res 生成一个 response 对象
  app.response = Object.create(res, {
    app: { configurable: true, enumerable: true, writable: true, value: app }
  })

  app.init();
  return app;
}
```



`proto` 是 `application.js` 导出的对象, 在这个对象上有包含 `listen`、`use` 等方法

```js
// app 就是 application.js导出的对象，也就是 proto
var app = exports = module.exports = {};

// 我们实际调用方式就是 app.listen, 所以在函数内部的this就是app
app.listen = function listen() {
  // 调用 app.listen 时，底层会用 http.createServer 创建服务器，然后调用 server.listen 启动。
  // 这里的this就是 app 本身 => 我们创建的app本质上就是一个有一堆属性的函数
  var server = http.createServer(this)
  
  var args = Array.prototype.slice.call(arguments)
  if (typeof args[args.length - 1] === 'function') {
    var done = args[args.length - 1] = once(args[args.length - 1])
    server.once('error', done)
  }
  
  // 这里的args就是我们传入的端口号，服务启动成功时候执行的回调函数等参数
  // 这里的server就是 http原生模块中 createServer方法返回的server对象
  // 调用http模块原生的listen方法去启动对应服务
  return server.listen.apply(server, args)
}
```

