`use`的核心逻辑是 

- **保存中间件**：app.use 会把你传的函数存到一个数组里。
- **匹配请求**：当请求到来时，Express 会根据路径和方法，遍历数组，找到匹配的函数执行。



`测试代码如下`

```js
// 示例代码：注册中间件
import express from 'express'

const app = express();

// 中间件 1
function f1(req, res, next) {
  console.log('中间件 1 执行');
  next(); // 调用 next，继续执行下一个中间件
}

// 中间件 2
function f2(req, res, next) {
  console.log('中间件 2 执行');
  next();
}

// 中间件 3
function f3(req, res) {
  console.log('中间件 3 执行');
  res.send('请求处理完成');
}

// 注册中间件
app.use(f1, f2, f3);

app.listen(8000, () => {
  console.log('服务器启动在 http://localhost:8000');
});
```



```js
// application.js => init方法
app.init = function init() {
  var router = null;

  this.cache = Object.create(null);
  this.engines = Object.create(null);
  this.settings = Object.create(null);

  this.defaultConfiguration();

  // 在应用的实例上，挂一个默认路由
  Object.defineProperty(this, 'router', {
    configurable: true,
    enumerable: true,
    get: function getrouter() {
      if (router === null) {
        router = new Router({
          caseSensitive: this.enabled('case sensitive routing'),
          strict: this.enabled('strict routing')
        });
      }

      return router;
    }
  });
};
```



```js
// application.js => use方法
app.use = function use(fn) {
  // 设置参数偏移量
  var offset = 0;
  //  默认路径为'/'
  var path = '/';

  // default path to '/'
  // disambiguate app.use([fn])
  if (typeof fn !== 'function') {
    var arg = fn;

    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }

    // 如果第一个参数不是函数，那么就说明，第一个参数是路径
    // 将路径保存到path中，并更新参数偏移量
    if (typeof arg !== 'function') {
      offset = 1;
      path = fn;
    }
  }

  // 通过 arguments 和 offset 获取所有中间件函数并存入 fns
  // 本例中 fns = [ f1, f2, f3 ]
  var fns = flatten.call(slice.call(arguments, offset), Infinity);

  if (fns.length === 0) {
    throw new TypeError('app.use() requires a middleware function')
  }

  // 获取路由，如果用户自定义了路由，那么将获取自定义路由
  // 如果用户没有自定义路由，将获取默认路由
  var router = this.router;

  // 迭代中间件
  fns.forEach(function (fn) {
    // non-express app
    if (!fn || !fn.handle || !fn.set) {
      // 将中间件转换为路径中间件并通过路由调用
      return router.use(path, fn);
    }

    debug('.use app under %s', path);
    fn.mountpath = path;
    fn.parent = this;

    // restore .app property on req and res
    router.use(path, function mounted_app(req, res, next) {
      var orig = req.app;
      fn.handle(req, res, function (err) {
        Object.setPrototypeOf(req, orig.request)
        Object.setPrototypeOf(res, orig.response)
        next(err);
      });
    });

    // mounted an app
    fn.emit('mount', this);
  }, this);

  return this;
};
```



```js
// router/index.js
Router.prototype.use = function use (handler) {
  let offset = 0
  let path = '/'

  // default path to '/'
  // disambiguate router.use([handler])
  if (typeof handler !== 'function') {
    let arg = handler

    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0]
    }

    // first arg is the path
    if (typeof arg !== 'function') {
      offset = 1
      path = handler
    }
  }

  // 提取出中间件路径 和 中间件处理函数
  const callbacks = flatten.call(slice.call(arguments, offset), Infinity)

  if (callbacks.length === 0) {
    throw new TypeError('argument handler is required')
  }

  for (let i = 0; i < callbacks.length; i++) {
    const fn = callbacks[i]

    if (typeof fn !== 'function') {
      throw new TypeError('argument handler must be a function')
    }

    // add the middleware
    debug('use %o %s', path, fn.name || '<anonymous>')

    // layer 是一个有 path，handle 等参数的对象
    const layer = new Layer(path, {
      sensitive: this.caseSensitive,
      strict: false,
      end: false
    }, fn)

    layer.route = undefined

    // stack是用于存放layer的数组
    this.stack.push(layer)
  }

  return this
}
```





----

源码里，use 函数会把中间件函数存到一个叫 stack 的数组里，每个中间件被封装成一个 Layer 对象，里面包含路径和函数信息。等请求来的时候，Express 就从 stack 里找匹配的 Layer，然后执行对应的函数。

----

*00:06:08 - 00:07:37*

如果 app.use 传了路径和多个函数，Express 会把函数从 arguments 里提取出来，存到 fns 数组。接着，它会检查有没有路由对象（router）。如果没有，就创建一个默认的路由，叫 lazy router。这个路由负责管理所有中间件。

Express 的路由机制很灵活，你可以自己创建路由（const router = express.Router()），但如果没创建，app.use 会用这个默认的 lazy router 来处理。

---

发url时，如何node debug
