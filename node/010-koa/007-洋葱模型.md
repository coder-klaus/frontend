## 架构形式

Express 默认集成了常用的中间件，而 Koa 只提供最核心的功能，其它功能都需要通过安装库来实现中间件。

这些库可以是官方、第三方，或者自己编写的。因此，Koa 相比 Express 拥有更高的灵活性。



## 中间件

Express 和 Koa 的核心都围绕“中间件”展开，不过两者的中间件执行机制并不相同。

中间件就是处理请求和响应的函数，可以在请求或响应被真正处理之前，进行一系列额外的操作

可以把中间件想象成一个拦截器，当有网络请求来的时候，Express 和 Koa 会根据请求的路径和方法，找到对应的中间件函数去执行。



## 洋葱模型

### koa-同步 执行逻辑

```js
import Koa from 'koa'
import Router from '@koa/router'

const app = new Koa()
const router = new Router()

router.get('/', (ctx, next) => {
  console.log('执行中间件1')
  next()
  console.log('反过头来执行中间件1')
  ctx.body = ctx.msg
})

router.get('/', (ctx, next) => {
  console.log('执行中间件2')
  next()
  console.log('反过头来执行中间件2')
})

router.get('/', (ctx, next) => {
  console.log('执行中间件3')
})

/*
  请求后，控制台输出
  + 执行中间件1
  + 执行中间件2
  + 执行中间件3
  + 反过头来执行中间件2
  + 反过头来执行中间件1
*/

app.use(router.routes()).use(router.allowedMethods())

app.listen(3000)
```

请求到来时，首先进入第一个中间件，遇到 `next()` 后进入第二个，以此类推。等最内层中间件执行完毕后，流程会“回溯”到上层中间件，继续执行 `next()` 后的逻辑。这种机制被称为 Koa 的“洋葱模型”——请求进来时一层层深入，处理完毕后再一层层返回，类似剥洋葱的过程。

简单来说，Koa 的洋葱模型就是：请求从外到内，响应从内到外。

![img](https://s2.loli.net/2025/06/23/3WRoPgExMadvbeA.png) ![clipboard.png](https://s2.loli.net/2025/06/23/sZfHupzL2wvG8M6.png)



### koa - 异步 执行逻辑

```js
import Koa from 'koa'
import Router from '@koa/router'

const app = new Koa()
const router = new Router()

function delay(msg) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(msg)
    }, 1000)
  })
}

router.get('/', async (ctx, next) => {
  ctx.msg = 'a'
  await next()
  ctx.body = ctx.msg // 'abc'
})

router.get('/', async (ctx, next) => {
  ctx.msg += 'b'
  await next()
})

router.get('/', async (ctx, next) => {
  ctx.msg += 'c'
})

/* 
  按照洋葱模型进行，第三个中间件是异步的
  所以在第二个中间件的next方法加上await，以等待异步中间件完成
  而相应的第二个中间件也变成了异步中间件，因此第一个中间件的next方法也必须加上await
*/

app.use(router.routes()).use(router.allowedMethods())
app.listen(3000)
```



### Express — 同步 执行逻辑

Express 的中间件执行顺序则不同：每个中间件执行 `next()` 后，直接进入下一个中间件，不会回到前一个中间件继续执行 `next()` 之后的代码。因此，Express 只存在“从外到内”的过程，没有“从内到外”的回溯。

简单来说，Koa 的 `next()` 返回 Promise，可以 `await`，而 Express 的 `next()` 返回 `void`，不支持异步等待和回溯。

```js
const express = require('express');
const app = express();

app.use((req, res, next) => {
  console.log('Express middleware 01');
  next();
  // 会报错，因为Express不会回溯代码
  res.json({ result: 'Express result 01' });
});

app.use((req, res, next) => {
  console.log('Express middleware 02');
  next();
});

app.use((req, res, next) => {
  console.log('Express middleware 03');
  next();
});

app.listen(9000);
```



### Express - 异步 执行逻辑

```js
import express from 'express'

const app = express()

function delay(msg) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(msg)
    }, 1000)
  })
}

app.use((req, res, next) => {
  req.msg = 'a'
  next()
})

app.use((req, res, next) => {
  req.msg += 'b'
  next()
})

app.use(async (req, res, next) => {
  // 异步中间件
  // Express不支持中间件回溯，但可以等待异步中间件执行完成后将处理结果交给下一个中间件处理
  const msg = await delay('c')
  req.msg += msg
  next()
})

app.use((req, res, next) => {
  // 最终输出 'abc'
  res.send(req.msg)
})

app.listen(3000)
```

