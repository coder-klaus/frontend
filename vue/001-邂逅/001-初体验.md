Vue 是基于 HTML、CSS 和 JavaScript 开发的JavaScript框架，用于编写用户界面，也就是我们的网页

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!--
    1. 注入全局对象 Vue
    2. 如果单独下载，一般放在 lib 目录中 「 lib 是 library 的缩写，专门放外部库文件」
  -->
  <script src="https://unpkg.com/vue@next"></script>
</head>
<body>
  <!--
      挂载点
      1. vue一般为 div#app， react 一般为 div#root
      2. 渲染后内容会作为挂载点的 innerHTML，替换挂载点中原本内容
      3. 挂载点本身不是应用，挂载点中内容才是应用
  -->
  <div id="app"></div>

  <script>
    // 通过 Vue.createApp 创建应用实例
    //  + 一个有 components、data、template、methods等属性的对象
    // 参数为根组件配置对象 => 如果不是标准配置对象，会自动转换为标准配置对象
    //   + SFC导入的组件在导出时会自动转换为标准配置对象
    //   + 本例中不是标准配置对象，vue底层会将其转化为标准配置对象 「 例如: 无论那种编写UI方式，都会转换为返回VDOM的render方法 」
    const app = Vue.createApp({
      // 指定状态
      // 1. 必须是返回转换对象的函数
      // 2. 函数中this是应用实例，即 app
      // 3. 之所以是函数，是为了确保组件每次调用时，返回的都是独立对象，避免跨组件状态污染
      data: () => ({ count: 0 }),
      // 指定方法
      // 1. 类型为 Record<string, Function>
      // 2. Function 的 this 是应用实例，即 app 「 所以不能使用箭头函数 」
      methods: {
        increment() {
          this.count++
        }
      },
      // 指定模板
      // 1. 如果是 #开头字符串，会作为id选择器，查找元素，并使用对象元素的innerHTML作为模板
      // 2. 如果是 非 #开头字符串，会作为普通字符串，作为模板内容
      // 3. 没有template选项，会自动将挂载点的 innerHTML 作为模板内容
      template: `<div>
        <h1>count: {{ count }}</h1>
        <button @click="increment">+</button>
      </div>`
    })

    // 渲染界面
    // + 参数可以是 1. 挂载点对应DOM元素 2. 挂载点选择器
    // + 返回的是根组件实例「 即一个存在 $data、$el等属性的对象 」
    app.mount('#app')
  </script>
</body>
</html>
```



## 响应式数据

如果某个数据同时满足如下两个条件就是状态

1. 参与了界面渲染
2. 值发生改变时，界面需要重新刷新

而 vue 对状态进行了劫持

1. vue2基于`Object.defineProperty`
2. vue3基于`proxy`

实现了当状态值更新时，自动识别哪些界面需要更新并自动重新进行渲染

因此在vue中的状态又叫响应式数据 或 响应式状态



## 双向绑定

数据驱动视图渲染 => 状态更新，界面自动更新

界面驱动状态更新 => 表单内容更新，对应状态自动更新

两者统称  双向数据驱动，又叫双向绑定



### MVC 和 MVVM

要实现数据驱动视图渲染有两种常见架构形式

+ MVC是Model – View –Controller的简称
+ MVVM是Model-View-ViewModel的简称

区别是

+ MVC 只实现了 数据驱动界面渲染。而界面驱动状态更新需要手动实现
+ MVVM 在MVC基础上进行改变，实现了双向数据绑定

![image.png](https://s2.loli.net/2022/07/25/f87ZuG1xRsKQBaX.png) 

其中 vue 就是一个类MVVM架构实现 「 vue 就是 vm 的角色 」

+ `Data Bindings`  => 将`model`中数据以声明式方式绑定到界面中，并实现响应式
+ `DOM Listeners` => 监听用户操作，并触发对应的事件处理函数

