## 渐进式

核心理念就是 **渐进增强**

+ 只提供核心功能，其余功能以库形式提供。用户可以按需进行选择

  + 这些库可以是官方的，也可以是第三方的，甚至可以是自己写的
  + 其中完成一个基本前端应用需要使用 vue + 路由 + 状态管理
    + 因此 vue + vue-router + pinia/vuex 也被称之为 vue全家桶

+ 另一个表现是 vue只会管理挂载点中的内容，其余部分并不归 vue管理

  + 因此理论上，可以在原有项目中**逐步引入**Vue，即一部分使用vue来进行开发，另一部分使用其它框架或原生进行开发 「 不常见 」
  
  
  

正式因为vue的渐进式特性，所以可以通过`createApp`创建多个应用实例

每个应用实例都是独立，互不影响的 「 不常见 」

```js
const app1 = createApp({
  /* ... */
})
app1.mount('#container-1')

const app2 = createApp({
  /* ... */
})
app2.mount('#container-2')
```

这也就是为什么，vue要求data必须是返回状态对象的工厂函数

如果直接定义对象，那么多个应用实例就会因为data的引用都指向同一个引用地址，而造成跨应用状态污染 或 跨组件状态污染



## 声明式

传统开发是命令式编程，即 how to do

我们需要告诉浏览器每一步的具体执行步骤

这就导致我们即需要处理业务逻辑，也需要关心界面的渲染和更新 「 DOM操作 」

如果操作不当，很容易因为DOM操作触发界面回流和重绘，而减低应用性能



现代前端开发 「 包括 vue 和 react 」都使用了声明式开发，更关注于 what to do

简单理解就是在 用户 和 浏览器之间 加入了一层框架

我们按照框架提供的语法去描述界面和业务逻辑，而框架会帮助我们实现界面的渲染和更新

简单描述就是 将DOM操作外包给了框架去实现



### VDOM

为了实现声明式编程，vue和react等现代框架使用了虚拟DOM 「 VDOM 」

虚拟DOM本质就是一个用于描述DOM结构的JavaScript对象，

但是这个对象往往只包含了框架所需要使用的属性和方法

因此

1. vdom 比 dom 更加轻量级
2. dom 和 vdom 是一一对应的

同时 因为 vdom本质是JavaScript对象，是渲染过程中的中间产物

1. 存在新旧DOM，可以进行DOM-DIFF
2. 方便实现 devTool 追踪状态改变，方便调试
3. 基于不同平台渲染不同内容，实现跨平台
   + CSR 浏览器 => DOM
   + SSR 服务端 => html string
   + 移动端 => 原生移动控件



### dom-diff

为了性能，每次更新肯定不是全量整体更新。

vue和react等现代框架会在每次更新时通过对新旧VDOM进行 dom-diff 算法对比

其核心是:

1. 只进行同层比较
   + 新节点去旧节点一个个比较，时间复杂度是 O(n^3^)
   + 只进行同层比较厚，时间复杂度变成了 O(n)
2. 如果节点不一致，直接将节点和子树全部销毁重建

通过 dom-diff，框架可以找到需要更新的最小DOM操作，被称之为 patch 补丁包

也就是说 每次更新，vdom树在内存中都是全量生成的，只不过实际进行的DOM操作最小化了



#### key

vue和react等框架要求，如果模板中存在循环创建元素，那么需要给每个元素一个稳定不变且唯一的`key`



这是因为 循环元素 每次更新前后 经常会发生更新和变动，而 dom-diff 只进行同层比较，

在 默认情况下，只能看到各个节点的 元素类型。因此只能通过判断节点类型是否一致，来判断节点是否复用，这种更新方式叫 旧地复用



但这种方式有一个弊端，那就是在更新过程中，有些节点可能只是进行了位置移动，并不需要销毁重建

此时就可以为每一个元素设置 key属性，这样框架在进行 dom-diff的时候，就可以更精确的识别每个节点了

「 key 就是节点的唯一身份标识 」

此时 dom-diff的基本流程如下 「  **双端比较 + LIS**   」

1. 从前往后进行比较，复用所有可以复用的节点，直到第一个无法复用的节点
2. 从后往前进行比较，复用所有可以复用的节点，直到第一个无法复用的节点
3. 判断剩余节点
   + 只有新节点，直接插入即可
   + 只有旧节点，直接删除即可
   + 如果新旧节点都存在，则通过 最长递增子序列算法「 LIS算法 」 找到可以复用的最长子节点列表
     + 复用子节点，并插入或移动剩余节点