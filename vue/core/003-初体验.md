```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 注入全局对象 Vue -->
  <!-- 如果下载到本地，第三方库一般存在于lib目录中 => library的缩写，专门放外部库文件 -->
  <script src="https://unpkg.com/vue@next"></script>
</head>
<body>
  <!-- 挂载点 -->
  <div id="app"></div>

  <script>
    const app = Vue.createApp({
      // vue3 中 data必须是函数，每次创建应用实例都是调用函数，返回独立对象，避免跨组件状态污染
      data: () => ({ msg: 'Hello Vue' }), // 指定状态
      template: `<div>{{ msg }}</div>` // 指定模板
    })

    // 渲染界面
    app.mount('#app')
  </script>
</body>
</html>
```



## 挂载点

1. vue一般为`div#app`, react 一般为`div#root`
2. 渲染后的内容会作为挂载点的innerHTML挂载到挂载点下
   + 会替换原本挂载点下的内容
   + 挂载点中的才是vue应用，挂载点本身并不是应用的一部分



## createApp

```js
const app = Vue.createApp({
  template: `<div>Hello Vue</div>`
})
```

1. 通过`createApp`创建应用实例 「 vue2一般叫`vm`、vue3一般叫`app` 」
2. 传入的参数可以是一个组件配置对象，也可以是 SFC（单文件组件）导出的对象。
   + 两者本质都是标准的 Vue 组件对象。
3. 传入的参数本质就是vue的根组件

> `crateApp`传入的组件对象会进行标准化处理，转换为标准组件对象
>
> SFC导出的本质也是标准化后的标准组件对象
>
> 1. 如果组件对象中包含  `template `或 `jsx`。在编译的时候，Vue 会自动将其编译为 `render` 函数。
> 2. `render` 函数会使用 `h`（也叫 `createVNode`）方法来描述虚拟 DOM 树。
>    + 这个 `h` 方法的作用类似于 React 的 `createElement`。
> 3. 每次调用 `render` 函数时，都会返回一棵虚拟 DOM（VNode）树，Vue 根据这棵树进行后续的渲染和更新。



## mount

1. 参数可以是
   + 字符串形式的css选择器
   + dom元素
2. 功能: 将VDOM渲染为整数DOM，并挂载到界面上

> `createApp`返回的是应用实例，存在`use`、`mount`等方法
>
> `mount`方法返回根组件实例，存在`$data`、`$el`等属性和方法





## template

1. 指定界面模板

2. template的查找规则如下:

   + 在`createApp`方法传入的配置对象中，如果`template`属性传入了不是以`#`开头的字符串,

     则自动将`template`属性中的值作为字符串形似的模板进行解析

   + 如果对应`template`属性的值是以`#`开头，会以`template`属性值作为元素的id值

     并将对应元素中的内容作为模板进行解析

   + 如果没有template属性，则自动将挂载点中的内容作为模板去进行解析



### **分类**

1. 字符串模板
   +  template选项 和 SFC中编写的模板
   +  vue 直接进行编译
      + 可以识别驼峰写法的组件名
      + 组件可以单闭合
2. DOM模板
   + 直接写在挂载点下的模板
   + 先被浏览器解析后再被vue解析
     + 会经过浏览器转换，无法是被大驼峰写法的组件名
     + 组件无法单闭合，只能双闭合，即使没有子元素



## app

应用实例有一个 `.config` 对象，可以用来设置一些全局的选项，比如设置一个全局的错误处理函数，捕获所有子组件的错误：

```js
app.config.errorHandler = (err) => {
  /* 处理错误 */
}
```

应用实例还可以用来注册全局资源，比如注册一个组件：

```js
app.component('TodoDeleteButton', TodoDeleteButton)
```



## 多个应用实例

`createApp` API 允许你在同一个页面里创建多个 Vue 应用，每个应用都有自己独立的配置和全局资源。

此时可以就可以使用Vue管理页面的某一个部分，而非全部。「 比较少见 」